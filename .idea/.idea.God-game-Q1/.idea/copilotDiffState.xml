<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Managers/TilemapManager.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Managers/TilemapManager.cs" />
              <option name="originalContent" value="using System;&#10;using UnityEngine;&#10;using System.Collections.Generic;&#10;using Components;&#10;&#10;public class TilemapManager : MonoBehaviour&#10;{&#10;    [SerializeField] private TilePool tilePool;&#10;    [SerializeField] private TileSelector tileSelector;&#10;&#10;    [field: SerializeField] public float tileHeight { get; private set; } = 0.2f;&#10;    [SerializeField] private float hexSize = 1f;&#10;    [SerializeField] private int maxHeight = 10;&#10;&#10;    [SerializeField] private float clickCooldown = 0.1f;&#10;&#10;    private Camera mainCamera;&#10;    private Vector2 currentMousePosition;&#10;    private float lastClickTime;&#10;    private float lastRightClickTime;&#10;&#10;    public Dictionary&lt;Vector3Int, GameObject&gt; tiles { get; } = new();&#10;    private Dictionary&lt;Vector2Int, int&gt; columnTopCoordinate = new();&#10;    private Dictionary&lt;Vector3Int, PosableObject&gt; placedObjects = new();&#10;    private Dictionary&lt;GameObject, bool&gt; prefabHasWaterSystem = new();&#10;    private HashSet&lt;Vector3Int&gt; waterTilePositions = new(); // Tracks positions with water tiles for O(1) lookups&#10;    public event Action&lt;Vector3Int&gt; columnModified;&#10;    public event Action startedPlacingTiles;&#10;    public event Action endedPlacingTiles;&#10;&#10;    public Vector3Int currentHexCoordinates { get; private set; }&#10;&#10;    public static TilemapManager instance { get; private set; }&#10;&#10;    public event Action&lt;Vector3Int&gt; tilePlaced;&#10;    public event Action&lt;Vector3Int&gt; tileRemoved;&#10;&#10;    public BoundsInt cellBounds&#10;    {&#10;        get&#10;        {&#10;            if (tiles.Count == 0)&#10;                return new BoundsInt(Vector3Int.zero, new Vector3Int(0, 0, 0));&#10;&#10;            int minHexColumn = int.MaxValue;&#10;            int maxHexColumn = int.MinValue;&#10;            int minHexRow = int.MaxValue;&#10;            int maxHexRow = int.MinValue;&#10;&#10;            foreach (var hexCoordinates in tiles.Keys)&#10;            {&#10;                if (hexCoordinates.x &lt; minHexColumn) minHexColumn = hexCoordinates.x;&#10;                if (hexCoordinates.x &gt; maxHexColumn) maxHexColumn = hexCoordinates.x;&#10;                if (hexCoordinates.y &lt; minHexRow) minHexRow = hexCoordinates.y;&#10;                if (hexCoordinates.y &gt; maxHexRow) maxHexRow = hexCoordinates.y;&#10;            }&#10;&#10;            Vector3 minWorldPosition = HexAxialToWorld(new Vector3Int(minHexColumn, minHexRow, 0));&#10;            Vector3 maxWorldPosition = HexAxialToWorld(new Vector3Int(maxHexColumn, maxHexRow, 0));&#10;&#10;            Vector3Int minBounds = new Vector3Int(&#10;                Mathf.FloorToInt(minWorldPosition.x - hexSize),&#10;                0,&#10;                Mathf.FloorToInt(minWorldPosition.z - hexSize)&#10;            );&#10;&#10;            Vector3Int maxBounds = new Vector3Int(&#10;                Mathf.CeilToInt(maxWorldPosition.x + hexSize),&#10;                0,&#10;                Mathf.CeilToInt(maxWorldPosition.z + hexSize)&#10;            );&#10;&#10;            Vector3Int boundsSize = maxBounds - minBounds;&#10;&#10;            return new BoundsInt(minBounds, boundsSize);&#10;        }&#10;    }&#10;&#10;    private void Awake()&#10;    {&#10;        if (instance == null)&#10;        {&#10;            instance = this;&#10;        }&#10;        else&#10;        {&#10;            Destroy(gameObject);&#10;        }&#10;    }&#10;&#10;    private void Start()&#10;    {&#10;        mainCamera = Camera.main;&#10;        if (mainCamera == null)&#10;        {&#10;            Debug.LogError(&quot;No main camera found in the scene!&quot;);&#10;        }&#10;&#10;        if (tilePool == null)&#10;        {&#10;            Debug.LogError(&quot;TilePool is not assigned to TilemapManager!&quot;);&#10;        }&#10;    }&#10;&#10;    private void Update()&#10;    {&#10;        UpdateMouseHexCoordinates();&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Converts the mouse screen position to hexagonal tilemap world coordinates to get the next placement of the tile.&#10;    /// &lt;/summary&gt;&#10;    private void UpdateMouseHexCoordinates()&#10;    {&#10;        Ray mouseRay = mainCamera.ScreenPointToRay(currentMousePosition);&#10;        RaycastHit rayHit;&#10;&#10;        Vector3 worldPosition;&#10;&#10;        if (Physics.Raycast(mouseRay, out rayHit))&#10;        {&#10;            worldPosition = rayHit.collider.transform.position;&#10;        }&#10;        else&#10;        {&#10;            Plane groundPlane = new Plane(Vector3.up, Vector3.zero);&#10;            float rayDistance;&#10;&#10;            if (groundPlane.Raycast(mouseRay, out rayDistance))&#10;            {&#10;                worldPosition = mouseRay.GetPoint(rayDistance);&#10;                DrawDebugCross(worldPosition, 0.5f, Color.cyan);&#10;            }&#10;            else&#10;            {&#10;                return;&#10;            }&#10;        }&#10;&#10;        currentHexCoordinates = WorldToHexAxial(worldPosition);&#10;    }&#10;&#10;    private void DrawDebugCross(Vector3 center, float size, Color color)&#10;    {&#10;        float halfSize = size / 2f;&#10;        Debug.DrawLine(center + Vector3.left * halfSize, center + Vector3.right * halfSize, color);&#10;        Debug.DrawLine(center + Vector3.forward * halfSize, center + Vector3.back * halfSize, color);&#10;        Debug.DrawLine(center + Vector3.up * halfSize, center + Vector3.down * halfSize, color);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Updates the mouse position from the input to be used for tile placement.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;mouseScreenPosition&quot;&gt; The current mouse screen position  &lt;/param&gt;&#10;    public void SetMousePos(Vector2 mouseScreenPosition)&#10;    {&#10;        currentMousePosition = mouseScreenPosition;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Checks if a prefab has a WaterSystem component (cached for performance)&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;prefab&quot;&gt;The prefab to check&lt;/param&gt;&#10;    /// &lt;returns&gt;True if the prefab has a WaterSystem component&lt;/returns&gt;&#10;    private bool PrefabHasWaterSystem(GameObject prefab)&#10;    {&#10;        if (!prefabHasWaterSystem.TryGetValue(prefab, out bool hasWaterSystem))&#10;        {&#10;            hasWaterSystem = prefab.GetComponent&lt;WaterComponent&gt;() != null;&#10;            prefabHasWaterSystem[prefab] = hasWaterSystem;&#10;        }&#10;&#10;        return hasWaterSystem;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Places tiles in brush area at the current mouse hex coordinates and updates the occlusion culling.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;tilePrefab&quot;&gt; The tile to place &lt;/param&gt;&#10;    public void PlaceTiles(GameObject prefab)&#10;    {&#10;        if (Time.time - lastClickTime &lt;&#10;            clickCooldown) // Simple click cooldown to prevent multiple placements on a single click&#10;        {&#10;            return;&#10;        }&#10;&#10;        lastClickTime = Time.time;&#10;        var brushArea = BrushSizeManager.instance.GetBrushArea(currentHexCoordinates);&#10;        startedPlacingTiles?.Invoke();&#10;&#10;        foreach (var hexCoordinate in brushArea)&#10;        {&#10;            int topCoordinate = GetColumnTopCoordinate(hexCoordinate);&#10;            Vector3Int tilePosition = new Vector3Int(hexCoordinate.x, hexCoordinate.y, topCoordinate + 1);&#10;            SpawnTileAt(tilePosition, prefab);&#10;        }&#10;&#10;        endedPlacingTiles?.Invoke();&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Places a tile at the specified hexagonal coordinates, replacing any existing tile and updating occlusion culling&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;hexCoordinates&quot;&gt; The coordinates in the hexagonal tilemap space &lt;/param&gt;&#10;    /// &lt;param name=&quot;tileData&quot;&gt; The tile data associated with the tile &lt;/param&gt;&#10;    public void SpawnTileAt(Vector3Int hexCoordinates, GameObject prefab)&#10;    {&#10;        if (hexCoordinates.z &gt;= maxHeight) // Prevents the tile from exceeding the maximum height&#10;        {&#10;            return;&#10;        }&#10;        bool isWaterPrefab = PrefabHasWaterSystem(prefab);&#10;&#10;        switch (!isWaterPrefab)&#10;        {&#10;            case true when placedObjects.ContainsKey(hexCoordinates):&#10;            {&#10;                var newPosition = hexCoordinates + new Vector3Int(0, 0, 1);&#10;                placedObjects[newPosition] = placedObjects[hexCoordinates];&#10;                placedObjects.Remove(hexCoordinates);&#10;                placedObjects[newPosition].transform.position = HexAxialToWorld(newPosition);&#10;                break;&#10;            }&#10;            case false when placedObjects.ContainsKey(hexCoordinates):&#10;            {&#10;                Destroy(placedObjects[hexCoordinates].gameObject);&#10;                placedObjects.Remove(hexCoordinates);&#10;                break;&#10;            }&#10;        }&#10;&#10;        if (tiles.ContainsKey(hexCoordinates)) // Check if a tile already exists at the specified coordinates&#10;            // because otherwise the tile will be replaced without being destroyed&#10;        {&#10;            GameObject existingTile = tiles[hexCoordinates];&#10;&#10;            if (existingTile != null)&#10;            {&#10;                tilePool.ReleaseTile(existingTile);&#10;            }&#10;&#10;            tiles.Remove(hexCoordinates);&#10;            // Remove from water positions if the existing tile was water&#10;            waterTilePositions.Remove(hexCoordinates);&#10;        }&#10;&#10;        Vector3 spawnPosition = HexAxialToWorld(hexCoordinates);&#10;        &#10;&#10;        GameObject newTile = tilePool.GetTile(prefab);&#10;        if (newTile == null)&#10;        {&#10;            Debug.LogError(&quot;Failed to get tile from pool!&quot;);&#10;            return;&#10;        }&#10;&#10;        newTile.transform.position = spawnPosition;&#10;        newTile.transform.rotation = Quaternion.identity;&#10;        newTile.name = $&quot;Tile_({hexCoordinates.x}, {hexCoordinates.y}, {hexCoordinates.z})&quot;;&#10;&#10;        tiles.Add(hexCoordinates, newTile);&#10;&#10;        // Track water tile positions for efficient water-on-water checks&#10;        if (isWaterPrefab)&#10;        {&#10;            waterTilePositions.Add(hexCoordinates);&#10;        }&#10;&#10;        Vector2Int columnKey = new Vector2Int(hexCoordinates.x, hexCoordinates.y);&#10;&#10;        if (!columnTopCoordinate.TryAdd(columnKey, 1))&#10;        {&#10;            columnTopCoordinate[columnKey] = hexCoordinates.z;&#10;        }&#10;&#10;        columnModified?.Invoke(hexCoordinates);&#10;&#10;        tilePlaced?.Invoke(hexCoordinates);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    ///  Tries to spawn an object at the current mouse hex coordinates if the underlying tile is allowed.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;objectPrefab&quot;&gt;&lt;/param&gt;&#10;    /// &lt;returns&gt;&lt;/returns&gt;&#10;    public bool TrySpawnObjectAtMouse(PosableObject objectPrefab)&#10;    {&#10;        if (Time.time - lastClickTime &lt;&#10;            clickCooldown) // Simple click cooldown to prevent multiple placements on a single click&#10;        {&#10;            return false;&#10;        }&#10;&#10;        lastClickTime = Time.time;&#10;        SpawnObjectAtMouse(objectPrefab);&#10;        return true;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    ///  Tries to spawn an entity at the current mouse hex coordinates if the underlying tile is allowed.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;entityPrefab&quot;&gt;&lt;/param&gt;&#10;    /// &lt;returns&gt;&lt;/returns&gt;&#10;    public bool TrySpawnEntityAtMouse(PosableEntity entityPrefab)&#10;    {&#10;        if (Time.time - lastClickTime &lt;&#10;            clickCooldown) // Simple click cooldown to prevent multiple placements on a single click&#10;        {&#10;            return false;&#10;        }&#10;&#10;        lastClickTime = Time.time;&#10;        SpawnEntityAtMouse(entityPrefab);&#10;        return true;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    ///  Tries to remove an entity at the current mouse hex coordinates.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt; Whether it actually removed the entity or not &lt;/returns&gt;&#10;    public bool TryRemoveEntityAtMouse()&#10;    {&#10;        if (Time.time - lastClickTime &lt;&#10;            clickCooldown) // Simple click cooldown to prevent multiple placements on a single click&#10;        {&#10;            return false;&#10;        }&#10;&#10;        lastClickTime = Time.time;&#10;        RemoveEntityAtMouse();&#10;        return true;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    ///  Removes an object at the current mouse hex coordinates.&#10;    /// &lt;/summary&gt;&#10;    private void RemoveEntityAtMouse()&#10;    {&#10;        var brushArea = BrushSizeManager.instance.GetBrushArea(currentHexCoordinates);&#10;&#10;        foreach (var hexCoordinate in brushArea)&#10;        {&#10;            int topCoordinate = GetColumnTopCoordinate(hexCoordinate);&#10;            Vector3Int tilePosition = new Vector3Int(hexCoordinate.x, hexCoordinate.y, topCoordinate + 1);&#10;&#10;            if (placedObjects.TryGetValue(tilePosition, out var posableObject))&#10;            {&#10;                Destroy(posableObject.gameObject);&#10;                placedObjects.Remove(tilePosition);&#10;            }&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    ///  Spawns an object at the current mouse hex coordinates.&#10;    /// &lt;/summary&gt;&#10;    public void SpawnObjectAtMouse(PosableObject objectPrefab)&#10;    {&#10;        SpawnPosableAtMouse(objectPrefab, true);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    ///  Spawns an entity at the current mouse hex coordinates.&#10;    /// &lt;/summary&gt;&#10;    public void SpawnEntityAtMouse(PosableEntity entityPrefab)&#10;    {&#10;        SpawnPosableAtMouse(entityPrefab, false);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    ///  Spawns a posable (object or entity) at the current mouse hex coordinates.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;posablePrefab&quot;&gt;The posable prefab to spawn&lt;/param&gt;&#10;    /// &lt;param name=&quot;storeInDictionary&quot;&gt;Whether to store the spawned posable in the placedObjects dictionary&lt;/param&gt;&#10;    private void SpawnPosableAtMouse(Posable posablePrefab, bool storeInDictionary)&#10;    {&#10;        var brushArea = BrushSizeManager.instance.GetBrushArea(currentHexCoordinates);&#10;&#10;        foreach (var hexCoordinate in brushArea)&#10;        {&#10;            int topCoordinate = GetColumnTopCoordinate(hexCoordinate);&#10;            Vector3Int tilePosition = new Vector3Int(hexCoordinate.x, hexCoordinate.y, topCoordinate);&#10;            GameObject tileAtPosition = GetTile(tilePosition);&#10;&#10;            if (tileAtPosition != null)&#10;            {&#10;                // Check if trying to place a PosableObject and one already exists at this position&#10;                if (posablePrefab is PosableObject &amp;&amp; placedObjects.ContainsKey(tilePosition))&#10;                {&#10;                    continue; // Skip this position&#10;                }&#10;&#10;                tilePosition.z += 1; // Place on top of the tile&#10;                Vector3 spawnPosition = HexAxialToWorld(tilePosition);&#10;                spawnPosition.y += tileHeight / 2f; // Adjust Y position to sit on top of the tile&#10;                GameObject tilePrefab = tilePool.GetOriginalPrefab(tileAtPosition);&#10;&#10;                if (tilePrefab != null &amp;&amp; posablePrefab.allowedTiles.Contains(tilePrefab))&#10;                {&#10;                    Posable newPosable = Instantiate(posablePrefab, spawnPosition, Quaternion.identity);&#10;                    string typeName = storeInDictionary ? &quot;Object&quot; : &quot;Entity&quot;;&#10;                    newPosable.name =&#10;                        $&quot;{typeName}_({currentHexCoordinates.x}, {currentHexCoordinates.y}, {currentHexCoordinates.z})&quot;;&#10;&#10;                    if (storeInDictionary &amp;&amp; newPosable is PosableObject posableObject)&#10;                    {&#10;                        placedObjects[tilePosition] = posableObject;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Converts world position to hexagonal axial coordinates.&#10;    /// &lt;/summary&gt;&#10;    public Vector3Int WorldToHexAxial(Vector3 worldPosition)&#10;    {&#10;        float hexInternalRadius = hexSize / 2f;&#10;&#10;        float worldX = worldPosition.x;&#10;        float worldZ = worldPosition.z;&#10;&#10;        float hexColumn = (2f / 3f * worldX) / hexInternalRadius;&#10;        float hexRow = (-1f / 3f * worldX + Mathf.Sqrt(3f) / 3f * worldZ) / hexInternalRadius;&#10;        float heightLevel = worldPosition.y / tileHeight;&#10;&#10;        return RoundToHexCoordinates(hexColumn, hexRow, heightLevel);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Round fractional hex coordinates to nearest hex axial coordinates.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;fractionalHexColumn&quot;&gt; x coordinate &lt;/param&gt;&#10;    /// &lt;param name=&quot;fractionalHexRow&quot;&gt; y coordinate &lt;/param&gt;&#10;    /// &lt;param name&quot;heightLevel&quot;&gt; z coordinate &lt;/param&gt;&#10;    /// &lt;returns&gt;&lt;/returns&gt;&#10;    private Vector3Int RoundToHexCoordinates(float fractionalHexColumn, float fractionalHexRow, float heightLevel)&#10;    {&#10;        float cubicS = -fractionalHexColumn - fractionalHexRow;&#10;&#10;        int roundedHexColumn = Mathf.RoundToInt(fractionalHexColumn);&#10;        int roundedHexRow = Mathf.RoundToInt(fractionalHexRow);&#10;        int roundedCubicS = Mathf.RoundToInt(cubicS);&#10;        int roundedHeightLevel = Mathf.RoundToInt(heightLevel);&#10;&#10;        float columnRoundingError = Mathf.Abs(roundedHexColumn - fractionalHexColumn);&#10;        float rowRoundingError = Mathf.Abs(roundedHexRow - fractionalHexRow);&#10;        float cubicSRoundingError = Mathf.Abs(roundedCubicS - cubicS);&#10;&#10;&#10;        if (columnRoundingError &gt; rowRoundingError &amp;&amp; columnRoundingError &gt; cubicSRoundingError)&#10;        {&#10;            roundedHexColumn = -roundedHexRow - roundedCubicS;&#10;        }&#10;        else if (rowRoundingError &gt; cubicSRoundingError)&#10;        {&#10;            roundedHexRow = -roundedHexColumn - roundedCubicS;&#10;        }&#10;&#10;        return new Vector3Int(roundedHexColumn, roundedHexRow, roundedHeightLevel);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Converts hexagonal axial coordinates to world position.&#10;    /// &lt;/summary&gt;&#10;    public Vector3 HexAxialToWorld(Vector3Int hexCoordinates)&#10;    {&#10;        float hexInternalRadius = hexSize / 2f;&#10;&#10;        float worldX = hexInternalRadius * (3f / 2f * hexCoordinates.x);&#10;        float worldZ = hexInternalRadius * (Mathf.Sqrt(3f) / 2f * hexCoordinates.x + Mathf.Sqrt(3f) * hexCoordinates.y);&#10;&#10;        float worldY = hexCoordinates.z * tileHeight;&#10;&#10;        //The y coordinate is calculated based on the height level of the tile&#10;        return new Vector3(worldX, worldY, worldZ);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Returns the tile GameObject at the specified hexagonal coordinates.&#10;    /// &lt;/summary&gt;&#10;    public GameObject GetTile(Vector3Int cellPos)&#10;    {&#10;        tiles.TryGetValue(cellPos, out GameObject tile);&#10;        return tile;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Returns the current height of the column at the specified hexagonal axial coordinates to place the next tile correctly.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;hexCoordinates&quot;&gt; The coordinates in 2D space of the column &lt;/param&gt;&#10;    public int GetColumnTopCoordinate(Vector2Int hexCoordinates)&#10;    {&#10;        if (columnTopCoordinate.TryGetValue(hexCoordinates, out int height))&#10;        {&#10;            return height;&#10;        }&#10;&#10;        columnTopCoordinate[hexCoordinates] = 0;&#10;        return 0;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Removes tiles in brush area at the current mouse hex coordinates and updates the occlusion culling.&#10;    /// &lt;/summary&gt;&#10;    public void RemoveTile()&#10;    {&#10;        if (Time.time - lastClickTime &lt; clickCooldown)&#10;        {&#10;            return;&#10;        }&#10;&#10;        lastClickTime = Time.time;&#10;        var brushArea = BrushSizeManager.instance.GetBrushArea(currentHexCoordinates);&#10;&#10;        startedPlacingTiles?.Invoke();&#10;&#10;        /*bool useBatchMode = brushArea.Length &gt; 1 &amp;&amp; occlusionCullingManager != null;&#10;        if (useBatchMode)&#10;        {&#10;            occlusionCullingManager.BeginBatch();&#10;        }*/&#10;&#10;        foreach (var hexCoordinate in brushArea)&#10;        {&#10;            int topCoordinate = GetColumnTopCoordinate(hexCoordinate);&#10;            RemoveTileAt(new Vector3Int(hexCoordinate.x, hexCoordinate.y, topCoordinate));&#10;        }&#10;&#10;        /*if (useBatchMode)&#10;        {&#10;            occlusionCullingManager.EndBatch();&#10;        }*/&#10;&#10;        endedPlacingTiles?.Invoke();&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Removes non-water tiles in brush area at the current mouse hex coordinates. Skips water tiles.&#10;    /// &lt;/summary&gt;&#10;    public void RemoveTileExceptWater()&#10;    {&#10;        if (Time.time - lastClickTime &lt; clickCooldown)&#10;        {&#10;            return;&#10;        }&#10;&#10;        lastClickTime = Time.time;&#10;        var brushArea = BrushSizeManager.instance.GetBrushArea(currentHexCoordinates);&#10;&#10;        startedPlacingTiles?.Invoke();&#10;&#10;        /*bool useBatchMode = brushArea.Length &gt; 1 &amp;&amp; occlusionCullingManager != null;&#10;        if (useBatchMode)&#10;        {&#10;            occlusionCullingManager.BeginBatch();&#10;        }*/&#10;&#10;        foreach (var hexCoordinate in brushArea)&#10;        {&#10;            int topCoordinate = GetColumnTopCoordinate(hexCoordinate);&#10;            Vector3Int tilePosition = new Vector3Int(hexCoordinate.x, hexCoordinate.y, topCoordinate);&#10;            &#10;            // Skip water tiles using O(1) HashSet lookup&#10;            if (!waterTilePositions.Contains(tilePosition))&#10;            {&#10;                RemoveTileAt(tilePosition);&#10;            }&#10;        }&#10;&#10;        /*if (useBatchMode)&#10;        {&#10;            occlusionCullingManager.EndBatch();&#10;        }*/&#10;&#10;        endedPlacingTiles?.Invoke();&#10;    }&#10;    &#10;    &#10;    /// &lt;summary&gt;&#10;    ///  Removes all water tiles at the specified hexagonal coordinates.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;hexCoordinates&quot;&gt; The coordinates in the hexagonal tilemap space &lt;/param&gt;&#10;    public void RemoveAllWaterAt(Vector3Int hexCoordinates)&#10;    {&#10;        var brushArea = BrushSizeManager.instance.GetBrushArea(hexCoordinates);&#10;&#10;        foreach (var hexCoordinate in brushArea)&#10;        {&#10;            int topCoordinate = GetColumnTopCoordinate(hexCoordinate);&#10;            &#10;            for (int z = topCoordinate; z &gt;= 0; z--)&#10;            {&#10;                Vector3Int tilePosition = new Vector3Int(hexCoordinate.x, hexCoordinate.y, z);&#10;                if (waterTilePositions.Contains(tilePosition))&#10;                {&#10;                    RemoveTileAt(tilePosition);&#10;                }&#10;                else&#10;                {&#10;                    break; // Stop if a non-water tile is encountered&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    ///  Removes the tile at the specified hexagonal coordinates, updates column height and occlusion culling.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;hexCoordinates&quot;&gt;&lt;/param&gt;&#10;    public void RemoveTileAt(Vector3Int hexCoordinates)&#10;    {&#10;        if (!tiles.TryGetValue(hexCoordinates, out var tileToRemove))&#10;            return;&#10;&#10;        if (tileToRemove != null)&#10;        {&#10;            tilePool.ReleaseTile(tileToRemove);&#10;        }&#10;&#10;        tiles.Remove(hexCoordinates);&#10;        &#10;        // Remove from water positions set if it was a water tile&#10;        waterTilePositions.Remove(hexCoordinates);&#10;&#10;        Vector2Int columnKey = new Vector2Int(hexCoordinates.x, hexCoordinates.y);&#10;        columnTopCoordinate[columnKey] = hexCoordinates.z - 1;&#10;        if (columnTopCoordinate[columnKey] &lt; 0)&#10;        {&#10;            columnTopCoordinate.Remove(columnKey);&#10;        }&#10;&#10;        columnModified?.Invoke(hexCoordinates);&#10;&#10;        /*if (occlusionCullingManager != null)&#10;        {&#10;            occlusionCullingManager.UpdateOcclusionForColumn(hexCoordinates);&#10;        }*/&#10;&#10;        tileRemoved?.Invoke(hexCoordinates);&#10;    }&#10;}" />
              <option name="updatedContent" value="using System;&#10;using UnityEngine;&#10;using System.Collections.Generic;&#10;using Components;&#10;&#10;public class TilemapManager : MonoBehaviour&#10;{&#10;    [SerializeField] private TilePool tilePool;&#10;    [SerializeField] private TileSelector tileSelector;&#10;&#10;    [field: SerializeField] public float tileHeight { get; private set; } = 0.2f;&#10;    [SerializeField] private float hexSize = 1f;&#10;    [SerializeField] private int maxHeight = 10;&#10;&#10;    [SerializeField] private float clickCooldown = 0.1f;&#10;&#10;    private Camera mainCamera;&#10;    private Vector2 currentMousePosition;&#10;    private float lastClickTime;&#10;    private float lastRightClickTime;&#10;&#10;    public Dictionary&lt;Vector3Int, GameObject&gt; tiles { get; } = new();&#10;    private Dictionary&lt;Vector2Int, int&gt; columnTopCoordinate = new();&#10;    private Dictionary&lt;Vector3Int, PosableObject&gt; placedObjects = new();&#10;    private Dictionary&lt;GameObject, bool&gt; prefabHasWaterSystem = new();&#10;    private HashSet&lt;Vector3Int&gt; waterTilePositions = new(); // Tracks positions with water tiles for O(1) lookups&#10;    public event Action&lt;Vector3Int&gt; columnModified;&#10;    public event Action startedPlacingTiles;&#10;    public event Action endedPlacingTiles;&#10;&#10;    public Vector3Int currentHexCoordinates { get; private set; }&#10;&#10;    public static TilemapManager instance { get; private set; }&#10;&#10;    public event Action&lt;Vector3Int&gt; tilePlaced;&#10;    public event Action&lt;Vector3Int&gt; tileRemoved;&#10;&#10;    public BoundsInt cellBounds&#10;    {&#10;        get&#10;        {&#10;            if (tiles.Count == 0)&#10;                return new BoundsInt(Vector3Int.zero, new Vector3Int(0, 0, 0));&#10;&#10;            int minHexColumn = int.MaxValue;&#10;            int maxHexColumn = int.MinValue;&#10;            int minHexRow = int.MaxValue;&#10;            int maxHexRow = int.MinValue;&#10;&#10;            foreach (var hexCoordinates in tiles.Keys)&#10;            {&#10;                if (hexCoordinates.x &lt; minHexColumn) minHexColumn = hexCoordinates.x;&#10;                if (hexCoordinates.x &gt; maxHexColumn) maxHexColumn = hexCoordinates.x;&#10;                if (hexCoordinates.y &lt; minHexRow) minHexRow = hexCoordinates.y;&#10;                if (hexCoordinates.y &gt; maxHexRow) maxHexRow = hexCoordinates.y;&#10;            }&#10;&#10;            Vector3 minWorldPosition = HexAxialToWorld(new Vector3Int(minHexColumn, minHexRow, 0));&#10;            Vector3 maxWorldPosition = HexAxialToWorld(new Vector3Int(maxHexColumn, maxHexRow, 0));&#10;&#10;            Vector3Int minBounds = new Vector3Int(&#10;                Mathf.FloorToInt(minWorldPosition.x - hexSize),&#10;                0,&#10;                Mathf.FloorToInt(minWorldPosition.z - hexSize)&#10;            );&#10;&#10;            Vector3Int maxBounds = new Vector3Int(&#10;                Mathf.CeilToInt(maxWorldPosition.x + hexSize),&#10;                0,&#10;                Mathf.CeilToInt(maxWorldPosition.z + hexSize)&#10;            );&#10;&#10;            Vector3Int boundsSize = maxBounds - minBounds;&#10;&#10;            return new BoundsInt(minBounds, boundsSize);&#10;        }&#10;    }&#10;&#10;    private void Awake()&#10;    {&#10;        if (instance == null)&#10;        {&#10;            instance = this;&#10;        }&#10;        else&#10;        {&#10;            Destroy(gameObject);&#10;        }&#10;    }&#10;&#10;    private void Start()&#10;    {&#10;        mainCamera = Camera.main;&#10;        if (mainCamera == null)&#10;        {&#10;            Debug.LogError(&quot;No main camera found in the scene!&quot;);&#10;        }&#10;&#10;        if (tilePool == null)&#10;        {&#10;            Debug.LogError(&quot;TilePool is not assigned to TilemapManager!&quot;);&#10;        }&#10;    }&#10;&#10;    private void Update()&#10;    {&#10;        UpdateMouseHexCoordinates();&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Converts the mouse screen position to hexagonal tilemap world coordinates to get the next placement of the tile.&#10;    /// &lt;/summary&gt;&#10;    private void UpdateMouseHexCoordinates()&#10;    {&#10;        Ray mouseRay = mainCamera.ScreenPointToRay(currentMousePosition);&#10;        RaycastHit rayHit;&#10;&#10;        Vector3 worldPosition;&#10;&#10;        if (Physics.Raycast(mouseRay, out rayHit))&#10;        {&#10;            worldPosition = rayHit.collider.transform.position;&#10;        }&#10;        else&#10;        {&#10;            Plane groundPlane = new Plane(Vector3.up, Vector3.zero);&#10;            float rayDistance;&#10;&#10;            if (groundPlane.Raycast(mouseRay, out rayDistance))&#10;            {&#10;                worldPosition = mouseRay.GetPoint(rayDistance);&#10;                DrawDebugCross(worldPosition, 0.5f, Color.cyan);&#10;            }&#10;            else&#10;            {&#10;                return;&#10;            }&#10;        }&#10;&#10;        currentHexCoordinates = WorldToHexAxial(worldPosition);&#10;    }&#10;&#10;    private void DrawDebugCross(Vector3 center, float size, Color color)&#10;    {&#10;        float halfSize = size / 2f;&#10;        Debug.DrawLine(center + Vector3.left * halfSize, center + Vector3.right * halfSize, color);&#10;        Debug.DrawLine(center + Vector3.forward * halfSize, center + Vector3.back * halfSize, color);&#10;        Debug.DrawLine(center + Vector3.up * halfSize, center + Vector3.down * halfSize, color);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Updates the mouse position from the input to be used for tile placement.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;mouseScreenPosition&quot;&gt; The current mouse screen position  &lt;/param&gt;&#10;    public void SetMousePos(Vector2 mouseScreenPosition)&#10;    {&#10;        currentMousePosition = mouseScreenPosition;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Checks if a prefab has a WaterSystem component (cached for performance)&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;prefab&quot;&gt;The prefab to check&lt;/param&gt;&#10;    /// &lt;returns&gt;True if the prefab has a WaterSystem component&lt;/returns&gt;&#10;    private bool PrefabHasWaterSystem(GameObject prefab)&#10;    {&#10;        if (!prefabHasWaterSystem.TryGetValue(prefab, out bool hasWaterSystem))&#10;        {&#10;            hasWaterSystem = prefab.GetComponent&lt;WaterComponent&gt;() != null;&#10;            prefabHasWaterSystem[prefab] = hasWaterSystem;&#10;        }&#10;&#10;        return hasWaterSystem;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Places tiles in brush area at the current mouse hex coordinates and updates the occlusion culling.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;tilePrefab&quot;&gt; The tile to place &lt;/param&gt;&#10;    public void PlaceTiles(GameObject prefab)&#10;    {&#10;        if (Time.time - lastClickTime &lt;&#10;            clickCooldown) // Simple click cooldown to prevent multiple placements on a single click&#10;        {&#10;            return;&#10;        }&#10;&#10;        lastClickTime = Time.time;&#10;        var brushArea = BrushSizeManager.instance.GetBrushArea(currentHexCoordinates);&#10;        startedPlacingTiles?.Invoke();&#10;&#10;        foreach (var hexCoordinate in brushArea)&#10;        {&#10;            int topCoordinate = GetColumnTopCoordinate(hexCoordinate);&#10;            Vector3Int tilePosition = new Vector3Int(hexCoordinate.x, hexCoordinate.y, topCoordinate + 1);&#10;            SpawnTileAt(tilePosition, prefab);&#10;        }&#10;&#10;        endedPlacingTiles?.Invoke();&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Places a tile at the specified hexagonal coordinates, replacing any existing tile and updating occlusion culling&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;hexCoordinates&quot;&gt; The coordinates in the hexagonal tilemap space &lt;/param&gt;&#10;    /// &lt;param name=&quot;tileData&quot;&gt; The tile data associated with the tile &lt;/param&gt;&#10;    public void SpawnTileAt(Vector3Int hexCoordinates, GameObject prefab)&#10;    {&#10;        if (hexCoordinates.z &gt;= maxHeight) // Prevents the tile from exceeding the maximum height&#10;        {&#10;            return;&#10;        }&#10;        bool isWaterPrefab = PrefabHasWaterSystem(prefab);&#10;&#10;        switch (!isWaterPrefab)&#10;        {&#10;            case true when placedObjects.ContainsKey(hexCoordinates):&#10;            {&#10;                var newPosition = hexCoordinates + new Vector3Int(0, 0, 1);&#10;                placedObjects[newPosition] = placedObjects[hexCoordinates];&#10;                placedObjects.Remove(hexCoordinates);&#10;                placedObjects[newPosition].transform.position = HexAxialToWorld(newPosition);&#10;                break;&#10;            }&#10;            case false when placedObjects.ContainsKey(hexCoordinates):&#10;            {&#10;                Destroy(placedObjects[hexCoordinates].gameObject);&#10;                placedObjects.Remove(hexCoordinates);&#10;                break;&#10;            }&#10;        }&#10;&#10;        if (tiles.ContainsKey(hexCoordinates)) // Check if a tile already exists at the specified coordinates&#10;            // because otherwise the tile will be replaced without being destroyed&#10;        {&#10;            GameObject existingTile = tiles[hexCoordinates];&#10;&#10;            if (existingTile != null)&#10;            {&#10;                tilePool.ReleaseTile(existingTile);&#10;            }&#10;&#10;            tiles.Remove(hexCoordinates);&#10;            // Remove from water positions if the existing tile was water&#10;            waterTilePositions.Remove(hexCoordinates);&#10;        }&#10;&#10;        Vector3 spawnPosition = HexAxialToWorld(hexCoordinates);&#10;        &#10;&#10;        GameObject newTile = tilePool.GetTile(prefab);&#10;        if (newTile == null)&#10;        {&#10;            Debug.LogError(&quot;Failed to get tile from pool!&quot;);&#10;            return;&#10;        }&#10;&#10;        newTile.transform.position = spawnPosition;&#10;        newTile.transform.rotation = Quaternion.identity;&#10;        newTile.name = $&quot;Tile_({hexCoordinates.x}, {hexCoordinates.y}, {hexCoordinates.z})&quot;;&#10;&#10;        tiles.Add(hexCoordinates, newTile);&#10;&#10;        // Track water tile positions for efficient water-on-water checks&#10;        if (isWaterPrefab)&#10;        {&#10;            waterTilePositions.Add(hexCoordinates);&#10;        }&#10;&#10;        Vector2Int columnKey = new Vector2Int(hexCoordinates.x, hexCoordinates.y);&#10;&#10;        if (!columnTopCoordinate.TryAdd(columnKey, 1))&#10;        {&#10;            columnTopCoordinate[columnKey] = hexCoordinates.z;&#10;        }&#10;&#10;        columnModified?.Invoke(hexCoordinates);&#10;&#10;        tilePlaced?.Invoke(hexCoordinates);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    ///  Tries to spawn an object at the current mouse hex coordinates if the underlying tile is allowed.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;objectPrefab&quot;&gt;&lt;/param&gt;&#10;    /// &lt;returns&gt;&lt;/returns&gt;&#10;    public bool TrySpawnObjectAtMouse(PosableObject objectPrefab)&#10;    {&#10;        if (Time.time - lastClickTime &lt;&#10;            clickCooldown) // Simple click cooldown to prevent multiple placements on a single click&#10;        {&#10;            return false;&#10;        }&#10;&#10;        lastClickTime = Time.time;&#10;        SpawnObjectAtMouse(objectPrefab);&#10;        return true;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    ///  Tries to spawn an entity at the current mouse hex coordinates if the underlying tile is allowed.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;entityPrefab&quot;&gt;&lt;/param&gt;&#10;    /// &lt;returns&gt;&lt;/returns&gt;&#10;    public bool TrySpawnEntityAtMouse(PosableEntity entityPrefab)&#10;    {&#10;        if (Time.time - lastClickTime &lt;&#10;            clickCooldown) // Simple click cooldown to prevent multiple placements on a single click&#10;        {&#10;            return false;&#10;        }&#10;&#10;        lastClickTime = Time.time;&#10;        SpawnEntityAtMouse(entityPrefab);&#10;        return true;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    ///  Tries to remove an entity at the current mouse hex coordinates.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt; Whether it actually removed the entity or not &lt;/returns&gt;&#10;    public bool TryRemoveEntityAtMouse()&#10;    {&#10;        if (Time.time - lastClickTime &lt;&#10;            clickCooldown) // Simple click cooldown to prevent multiple placements on a single click&#10;        {&#10;            return false;&#10;        }&#10;&#10;        lastClickTime = Time.time;&#10;        RemoveEntityAtMouse();&#10;        return true;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    ///  Removes an object at the current mouse hex coordinates.&#10;    /// &lt;/summary&gt;&#10;    private void RemoveEntityAtMouse()&#10;    {&#10;        var brushArea = BrushSizeManager.instance.GetBrushArea(currentHexCoordinates);&#10;&#10;        foreach (var hexCoordinate in brushArea)&#10;        {&#10;            int topCoordinate = GetColumnTopCoordinate(hexCoordinate);&#10;            Vector3Int tilePosition = new Vector3Int(hexCoordinate.x, hexCoordinate.y, topCoordinate + 1);&#10;&#10;            if (placedObjects.TryGetValue(tilePosition, out var posableObject))&#10;            {&#10;                Destroy(posableObject.gameObject);&#10;                placedObjects.Remove(tilePosition);&#10;            }&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    ///  Spawns an object at the current mouse hex coordinates.&#10;    /// &lt;/summary&gt;&#10;    public void SpawnObjectAtMouse(PosableObject objectPrefab)&#10;    {&#10;        SpawnPosableAtMouse(objectPrefab, true);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    ///  Spawns an entity at the current mouse hex coordinates.&#10;    /// &lt;/summary&gt;&#10;    public void SpawnEntityAtMouse(PosableEntity entityPrefab)&#10;    {&#10;        SpawnPosableAtMouse(entityPrefab, false);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    ///  Spawns a posable (object or entity) at the current mouse hex coordinates.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;posablePrefab&quot;&gt;The posable prefab to spawn&lt;/param&gt;&#10;    /// &lt;param name=&quot;storeInDictionary&quot;&gt;Whether to store the spawned posable in the placedObjects dictionary&lt;/param&gt;&#10;    private void SpawnPosableAtMouse(Posable posablePrefab, bool storeInDictionary)&#10;    {&#10;        var brushArea = BrushSizeManager.instance.GetBrushArea(currentHexCoordinates);&#10;&#10;        foreach (var hexCoordinate in brushArea)&#10;        {&#10;            int topCoordinate = GetColumnTopCoordinate(hexCoordinate);&#10;            Vector3Int tilePosition = new Vector3Int(hexCoordinate.x, hexCoordinate.y, topCoordinate);&#10;            GameObject tileAtPosition = GetTile(tilePosition);&#10;&#10;            if (tileAtPosition != null)&#10;            {&#10;                // Check if trying to place a PosableObject and one already exists at this position&#10;                if (posablePrefab is PosableObject &amp;&amp; placedObjects.ContainsKey(tilePosition))&#10;                {&#10;                    continue; // Skip this position&#10;                }&#10;&#10;                tilePosition.z += 1; // Place on top of the tile&#10;                Vector3 spawnPosition = HexAxialToWorld(tilePosition);&#10;                spawnPosition.y += tileHeight / 2f; // Adjust Y position to sit on top of the tile&#10;                GameObject tilePrefab = tilePool.GetOriginalPrefab(tileAtPosition);&#10;&#10;                if (tilePrefab != null &amp;&amp; posablePrefab.allowedTiles.Contains(tilePrefab))&#10;                {&#10;                    Posable newPosable = Instantiate(posablePrefab, spawnPosition, Quaternion.identity);&#10;                    string typeName = storeInDictionary ? &quot;Object&quot; : &quot;Entity&quot;;&#10;                    newPosable.name =&#10;                        $&quot;{typeName}_({currentHexCoordinates.x}, {currentHexCoordinates.y}, {currentHexCoordinates.z})&quot;;&#10;&#10;                    if (storeInDictionary &amp;&amp; newPosable is PosableObject posableObject)&#10;                    {&#10;                        placedObjects[tilePosition] = posableObject;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Converts world position to hexagonal axial coordinates.&#10;    /// &lt;/summary&gt;&#10;    public Vector3Int WorldToHexAxial(Vector3 worldPosition)&#10;    {&#10;        float hexInternalRadius = hexSize / 2f;&#10;&#10;        float worldX = worldPosition.x;&#10;        float worldZ = worldPosition.z;&#10;&#10;        float hexColumn = (2f / 3f * worldX) / hexInternalRadius;&#10;        float hexRow = (-1f / 3f * worldX + Mathf.Sqrt(3f) / 3f * worldZ) / hexInternalRadius;&#10;        float heightLevel = worldPosition.y / tileHeight;&#10;&#10;        return RoundToHexCoordinates(hexColumn, hexRow, heightLevel);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Round fractional hex coordinates to nearest hex axial coordinates.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;fractionalHexColumn&quot;&gt; x coordinate &lt;/param&gt;&#10;    /// &lt;param name=&quot;fractionalHexRow&quot;&gt; y coordinate &lt;/param&gt;&#10;    /// &lt;param name&quot;heightLevel&quot;&gt; z coordinate &lt;/param&gt;&#10;    /// &lt;returns&gt;&lt;/returns&gt;&#10;    private Vector3Int RoundToHexCoordinates(float fractionalHexColumn, float fractionalHexRow, float heightLevel)&#10;    {&#10;        float cubicS = -fractionalHexColumn - fractionalHexRow;&#10;&#10;        int roundedHexColumn = Mathf.RoundToInt(fractionalHexColumn);&#10;        int roundedHexRow = Mathf.RoundToInt(fractionalHexRow);&#10;        int roundedCubicS = Mathf.RoundToInt(cubicS);&#10;        int roundedHeightLevel = Mathf.RoundToInt(heightLevel);&#10;&#10;        float columnRoundingError = Mathf.Abs(roundedHexColumn - fractionalHexColumn);&#10;        float rowRoundingError = Mathf.Abs(roundedHexRow - fractionalHexRow);&#10;        float cubicSRoundingError = Mathf.Abs(roundedCubicS - cubicS);&#10;&#10;&#10;        if (columnRoundingError &gt; rowRoundingError &amp;&amp; columnRoundingError &gt; cubicSRoundingError)&#10;        {&#10;            roundedHexColumn = -roundedHexRow - roundedCubicS;&#10;        }&#10;        else if (rowRoundingError &gt; cubicSRoundingError)&#10;        {&#10;            roundedHexRow = -roundedHexColumn - roundedCubicS;&#10;        }&#10;&#10;        return new Vector3Int(roundedHexColumn, roundedHexRow, roundedHeightLevel);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Converts hexagonal axial coordinates to world position.&#10;    /// &lt;/summary&gt;&#10;    public Vector3 HexAxialToWorld(Vector3Int hexCoordinates)&#10;    {&#10;        float hexInternalRadius = hexSize / 2f;&#10;&#10;        float worldX = hexInternalRadius * (3f / 2f * hexCoordinates.x);&#10;        float worldZ = hexInternalRadius * (Mathf.Sqrt(3f) / 2f * hexCoordinates.x + Mathf.Sqrt(3f) * hexCoordinates.y);&#10;&#10;        float worldY = hexCoordinates.z * tileHeight;&#10;&#10;        //The y coordinate is calculated based on the height level of the tile&#10;        return new Vector3(worldX, worldY, worldZ);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Returns the tile GameObject at the specified hexagonal coordinates.&#10;    /// &lt;/summary&gt;&#10;    public GameObject GetTile(Vector3Int cellPos)&#10;    {&#10;        tiles.TryGetValue(cellPos, out GameObject tile);&#10;        return tile;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Returns the current height of the column at the specified hexagonal axial coordinates to place the next tile correctly.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;hexCoordinates&quot;&gt; The coordinates in 2D space of the column &lt;/param&gt;&#10;    public int GetColumnTopCoordinate(Vector2Int hexCoordinates)&#10;    {&#10;        if (columnTopCoordinate.TryGetValue(hexCoordinates, out int height))&#10;        {&#10;            return height;&#10;        }&#10;&#10;        columnTopCoordinate[hexCoordinates] = 0;&#10;        return 0;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Removes tiles in brush area at the current mouse hex coordinates and updates the occlusion culling.&#10;    /// &lt;/summary&gt;&#10;    public void RemoveTile()&#10;    {&#10;        if (Time.time - lastClickTime &lt; clickCooldown)&#10;        {&#10;            return;&#10;        }&#10;&#10;        lastClickTime = Time.time;&#10;        var brushArea = BrushSizeManager.instance.GetBrushArea(currentHexCoordinates);&#10;&#10;        startedPlacingTiles?.Invoke();&#10;&#10;        /*bool useBatchMode = brushArea.Length &gt; 1 &amp;&amp; occlusionCullingManager != null;&#10;        if (useBatchMode)&#10;        {&#10;            occlusionCullingManager.BeginBatch();&#10;        }*/&#10;&#10;        foreach (var hexCoordinate in brushArea)&#10;        {&#10;            int topCoordinate = GetColumnTopCoordinate(hexCoordinate);&#10;            RemoveTileAt(new Vector3Int(hexCoordinate.x, hexCoordinate.y, topCoordinate));&#10;        }&#10;&#10;        /*if (useBatchMode)&#10;        {&#10;            occlusionCullingManager.EndBatch();&#10;        }*/&#10;&#10;        endedPlacingTiles?.Invoke();&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Removes non-water tiles in brush area at the current mouse hex coordinates. Skips water tiles.&#10;    /// &lt;/summary&gt;&#10;    public void RemoveTileExceptWater()&#10;    {&#10;        if (Time.time - lastClickTime &lt; clickCooldown)&#10;        {&#10;            return;&#10;        }&#10;&#10;        lastClickTime = Time.time;&#10;        var brushArea = BrushSizeManager.instance.GetBrushArea(currentHexCoordinates);&#10;&#10;        startedPlacingTiles?.Invoke();&#10;&#10;        /*bool useBatchMode = brushArea.Length &gt; 1 &amp;&amp; occlusionCullingManager != null;&#10;        if (useBatchMode)&#10;        {&#10;            occlusionCullingManager.BeginBatch();&#10;        }*/&#10;&#10;        foreach (var hexCoordinate in brushArea)&#10;        {&#10;            int topCoordinate = GetColumnTopCoordinate(hexCoordinate);&#10;            Vector3Int tilePosition = new Vector3Int(hexCoordinate.x, hexCoordinate.y, topCoordinate);&#10;            &#10;            // Skip water tiles using O(1) HashSet lookup&#10;            if (!waterTilePositions.Contains(tilePosition))&#10;            {&#10;                RemoveTileAt(tilePosition);&#10;            }&#10;        }&#10;&#10;        /*if (useBatchMode)&#10;        {&#10;            occlusionCullingManager.EndBatch();&#10;        }*/&#10;&#10;        endedPlacingTiles?.Invoke();&#10;    }&#10;    &#10;    &#10;    /// &lt;summary&gt;&#10;    ///  Removes all water tiles at the specified hexagonal coordinates.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;hexCoordinates&quot;&gt; The coordinates in the hexagonal tilemap space &lt;/param&gt;&#10;    public void RemoveAllWaterAt(Vector3Int hexCoordinates)&#10;    {&#10;        var brushArea = BrushSizeManager.instance.GetBrushArea(hexCoordinates);&#10;&#10;        foreach (var hexCoordinate in brushArea)&#10;        {&#10;            int topCoordinate = GetColumnTopCoordinate(hexCoordinate);&#10;            &#10;            for (int z = topCoordinate; z &gt;= 0; z--)&#10;            {&#10;                Vector3Int tilePosition = new Vector3Int(hexCoordinate.x, hexCoordinate.y, z);&#10;                if (waterTilePositions.Contains(tilePosition))&#10;                {&#10;                    RemoveTileAt(tilePosition);&#10;                }&#10;                else&#10;                {&#10;                    break; // Stop if a non-water tile is encountered&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    ///  Removes the tile at the specified hexagonal coordinates, updates column height and occlusion culling.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;hexCoordinates&quot;&gt;&lt;/param&gt;&#10;    public void RemoveTileAt(Vector3Int hexCoordinates)&#10;    {&#10;        if (!tiles.TryGetValue(hexCoordinates, out var tileToRemove))&#10;            return;&#10;&#10;        if (tileToRemove != null)&#10;        {&#10;            tilePool.ReleaseTile(tileToRemove);&#10;        }&#10;&#10;        tiles.Remove(hexCoordinates);&#10;        &#10;        // Remove from water positions set if it was a water tile&#10;        waterTilePositions.Remove(hexCoordinates);&#10;&#10;        Vector2Int columnKey = new Vector2Int(hexCoordinates.x, hexCoordinates.y);&#10;        columnTopCoordinate[columnKey] = hexCoordinates.z - 1;&#10;        if (columnTopCoordinate[columnKey] &lt; 0)&#10;        {&#10;            columnTopCoordinate.Remove(columnKey);&#10;        }&#10;&#10;        columnModified?.Invoke(hexCoordinates);&#10;&#10;        /*if (occlusionCullingManager != null)&#10;        {&#10;            occlusionCullingManager.UpdateOcclusionForColumn(hexCoordinates);&#10;        }*/&#10;&#10;        tileRemoved?.Invoke(hexCoordinates);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/TILEMAP_HEIGHT_OPTIMIZATION.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/TILEMAP_HEIGHT_OPTIMIZATION.md" />
              <option name="updatedContent" value="# TilemapManager Height System Optimization&#10;&#10;## Date&#10;December 5, 2025&#10;&#10;## Problem&#10;The original implementation was **extremely inefficient** when getting column heights:&#10;- **O(n) complexity** - iterated through ALL tiles every time `GetColumnHeight()` was called&#10;- With thousands of tiles, this caused massive performance issues&#10;- When placing many tiles per tick (brush painting), this multiplied the problem&#10;&#10;## Solution&#10;Added a separate `columnHeights` dictionary to track the maximum height of each column.&#10;&#10;### New Data Structure&#10;```csharp&#10;private Dictionary&lt;Vector2Int, int&gt; columnHeights = new();&#10;```&#10;- **Key**: `Vector2Int(q, r)` - the hex coordinates&#10;- **Value**: `int` - the next available height (current max height + 1)&#10;&#10;## Performance Improvement&#10;&#10;### Before (O(n))&#10;```csharp&#10;public int GetColumnHeight(int q, int r)&#10;{&#10;    int maxZ = 0;&#10;    foreach (var kvp in tiles) // Iterates through ALL tiles&#10;    {&#10;        Vector3Int key = kvp.Key;&#10;        if (key.x == q &amp;&amp; key.y == r)&#10;        {&#10;            if (key.z &gt;= maxZ)&#10;            {&#10;                maxZ = key.z + 1;&#10;            }&#10;        }&#10;    }&#10;    return maxZ;&#10;}&#10;```&#10;- **Complexity**: O(n) where n = total number of tiles in the scene&#10;- **Example**: With 10,000 tiles, checking 100 columns = 1,000,000 comparisons&#10;&#10;### After (O(1))&#10;```csharp&#10;public int GetColumnHeight(int q, int r)&#10;{&#10;    Vector2Int key = new Vector2Int(q, r);&#10;    return columnHeights.TryGetValue(key, out int height) ? height : 0;&#10;}&#10;```&#10;- **Complexity**: O(1) - constant time dictionary lookup&#10;- **Example**: With 10,000 tiles, checking 100 columns = 100 lookups&#10;&#10;## Speed Improvement&#10;- **Theoretical**: 10,000x faster for 10,000 tiles&#10;- **Practical**: Instant lookups regardless of tile count&#10;&#10;## Implementation Details&#10;&#10;### 1. SpawnTileAt() Updates&#10;```csharp&#10;// Update column height tracker&#10;Vector2Int columnKey = new Vector2Int(hexCoords.x, hexCoords.y);&#10;int newHeight = hexCoords.z + 1; // +1 because z is 0-indexed&#10;if (!columnHeights.ContainsKey(columnKey) || columnHeights[columnKey] &lt; newHeight)&#10;{&#10;    columnHeights[columnKey] = newHeight;&#10;}&#10;```&#10;- When a tile is spawned, update the column height if necessary&#10;- Only updates if the new tile is taller than existing height&#10;&#10;### 2. RemoveColumn() Updates&#10;```csharp&#10;// Update column height tracker - remove the column entry&#10;Vector2Int columnKey = new Vector2Int(q, r);&#10;columnHeights.Remove(columnKey);&#10;```&#10;- When an entire column is removed, delete the height entry&#10;- The column height will be recalculated if tiles are added later&#10;&#10;## Memory Trade-off&#10;- **Additional Memory**: ~12 bytes per unique column (Vector2Int + int)&#10;- **Example**: 1,000 columns = ~12 KB&#10;- **Benefit**: Massive performance improvement for negligible memory cost&#10;&#10;## Edge Cases Handled&#10;1. **New column**: Returns 0 (spawn at ground level)&#10;2. **Removed column**: Entry deleted, returns 0 for next spawn&#10;3. **Partial column removal**: Not currently supported (would need recalculation)&#10;4. **Replace mode**: Removes entire column, resets height to 0&#10;&#10;## Future Optimizations (if needed)&#10;1. **Serialize columnHeights**: Save/load to avoid recalculation on scene load&#10;2. **Partial removal support**: Track individual tile removals and recalculate height&#10;3. **Height queries by range**: Add method to get all columns within a height range&#10;&#10;## Testing Notes&#10;- Place tiles with large brush sizes - should be instant now&#10;- Build tall columns - height tracking should be accurate&#10;- Replace columns - heights should reset correctly&#10;- Performance should scale with number of columns, not total tiles&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>