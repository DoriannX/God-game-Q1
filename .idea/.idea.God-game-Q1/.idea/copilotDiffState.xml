<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Managers/TileHeightManager.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Managers/TileHeightManager.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using System.Collections.Generic;&#10;&#10;public class TileHeightManager : MonoBehaviour&#10;{&#10;    [SerializeField] private TilePool tilePool; // Référence au pool de tiles&#10;    [SerializeField] private float tileHeight = .2f; // Hauteur d'une tile individuelle&#10;    [SerializeField] private float clickCooldown = 0.1f; // Temps minimum entre deux clics (en secondes)&#10;    [SerializeField] private BrushSizeManager brushManager; // Référence au BrushSizeManager&#10;    [SerializeField] private float hexSize = 1f; // Largeur de l'hexagone (doit correspondre à TilemapManagerCopy)&#10;    &#10;    private Camera mainCamera;&#10;    // Dictionnaire qui stocke les colonnes de tiles par coordonnées hexagonales&#10;    // La clé est (q, r), la valeur est une liste de GameObjects empilés&#10;    private Dictionary&lt;Vector2Int, List&lt;GameObject&gt;&gt; tileColumns = new Dictionary&lt;Vector2Int, List&lt;GameObject&gt;&gt;();&#10;    private float lastClickTime; // Temps du dernier clic&#10;    &#10;    private void Start()&#10;    {&#10;        mainCamera = Camera.main;&#10;        if (mainCamera == null)&#10;        {&#10;            Debug.LogError(&quot;No main camera found in the scene!&quot;);&#10;        }&#10;        &#10;        if (tilePool == null)&#10;        {&#10;            Debug.LogError(&quot;TilePool is not assigned to TileHeightManager!&quot;);&#10;        }&#10;    }&#10;    &#10;    private void Update()&#10;    {&#10;        // Détecter le clic droit de la souris&#10;        if (Input.GetMouseButton(1))&#10;        {&#10;            // Vérifier si le cooldown est écoulé&#10;            if (Time.time &gt;= lastClickTime + clickCooldown)&#10;            {&#10;                // Shift + clic droit = baisser la colonne&#10;                if (Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift))&#10;                {&#10;                    DetectTileClickToLower();&#10;                }&#10;                else&#10;                {&#10;                    // Clic droit seul = monter la colonne&#10;                    DetectTileClick();&#10;                }&#10;                lastClickTime = Time.time;&#10;            }&#10;        }&#10;    }&#10;    &#10;    private void DetectTileClick()&#10;    {&#10;        // Obtenir la position de la souris à l'écran&#10;        Vector3 mouseScreenPosition = Input.mousePosition;&#10;        &#10;        // Créer un raycast depuis la caméra vers la position de la souris&#10;        Ray ray = mainCamera.ScreenPointToRay(mouseScreenPosition);&#10;        &#10;        // Calculer l'intersection avec le plan Y = 0 (comme BrushPreview)&#10;        Plane groundPlane = new Plane(Vector3.up, Vector3.zero);&#10;        float distance;&#10;        &#10;        if (groundPlane.Raycast(ray, out distance))&#10;        {&#10;            Vector3 worldPosition = ray.GetPoint(distance);&#10;            &#10;            // Visualiser le raycast en jaune&#10;            Debug.DrawRay(ray.origin, ray.direction * distance, Color.yellow, 2f);&#10;            &#10;            // Debug.Log désactivé pour éviter le spam&#10;            // Debug.Log($&quot;Click at world position: {worldPosition}, hex coords: ({hexCoords.x}, {hexCoords.y})&quot;);&#10;            &#10;            // Convertir la position world en coordonnées hexagonales (comme BrushPreview)&#10;            Vector2Int hexCoords = WorldToHexAxial(worldPosition);&#10;            &#10;            // Debug.Log désactivé pour éviter le spam&#10;            // Debug.Log($&quot;Raising {brushArea.Length} columns with brush size {brushManager.GetBrushSize()}&quot;);&#10;            &#10;            // Obtenir la zone du brush&#10;            Vector2Int[] brushArea;&#10;            if (brushManager != null)&#10;            {&#10;                brushArea = brushManager.GetBrushArea(hexCoords);&#10;                // Debug.Log désactivé pour éviter le spam&#10;                // Debug.Log($&quot;Raising {brushArea.Length} columns with brush size {brushManager.GetBrushSize()}&quot;);&#10;            }&#10;            else&#10;            {&#10;                // Si pas de brush manager, monter seulement une colonne&#10;                brushArea = new Vector2Int[] { hexCoords };&#10;            }&#10;            &#10;            // Monter toutes les colonnes dans la zone du brush&#10;            foreach (Vector2Int coord in brushArea)&#10;            {&#10;                RaiseColumn(coord);&#10;            }&#10;        }&#10;        else&#10;        {&#10;            Debug.DrawRay(ray.origin, ray.direction * 100f, Color.red, 2f);&#10;        }&#10;    }&#10;    &#10;    private void DetectTileClickToLower()&#10;    {&#10;        // Obtenir la position de la souris à l'écran&#10;        Vector3 mouseScreenPosition = Input.mousePosition;&#10;        &#10;        // Créer un raycast depuis la caméra vers la position de la souris&#10;        Ray ray = mainCamera.ScreenPointToRay(mouseScreenPosition);&#10;        &#10;        // Calculer l'intersection avec le plan Y = 0 (comme BrushPreview)&#10;        Plane groundPlane = new Plane(Vector3.up, Vector3.zero);&#10;        float distance;&#10;        &#10;        if (groundPlane.Raycast(ray, out distance))&#10;        {&#10;            Vector3 worldPosition = ray.GetPoint(distance);&#10;            &#10;            // Visualiser le raycast en magenta&#10;            Debug.DrawRay(ray.origin, ray.direction * distance, Color.magenta, 2f);&#10;            &#10;            // Convertir la position world en coordonnées hexagonales (comme BrushPreview)&#10;            Vector2Int hexCoords = WorldToHexAxial(worldPosition);&#10;            &#10;            // Debug.Log désactivé pour éviter le spam&#10;            // Debug.Log($&quot;Shift+Click at world position: {worldPosition}, hex coords: ({hexCoords.x}, {hexCoords.y})&quot;);&#10;            &#10;            // Obtenir la zone du brush&#10;            Vector2Int[] brushArea;&#10;            if (brushManager != null)&#10;            {&#10;                brushArea = brushManager.GetBrushArea(hexCoords);&#10;                // Debug.Log désactivé pour éviter le spam&#10;                // Debug.Log($&quot;Lowering {brushArea.Length} columns with brush size {brushManager.GetBrushSize()}&quot;);&#10;            }&#10;            else&#10;            {&#10;                // Si pas de brush manager, baisser seulement une colonne&#10;                brushArea = new Vector2Int[] { hexCoords };&#10;            }&#10;            &#10;            // Baisser toutes les colonnes dans la zone du brush&#10;            foreach (Vector2Int coord in brushArea)&#10;            {&#10;                LowerColumn(coord);&#10;            }&#10;        }&#10;        else&#10;        {&#10;            Debug.DrawRay(ray.origin, ray.direction * 100f, Color.red, 2f);&#10;        }&#10;    }&#10;    &#10;    private void RaiseColumn(Vector2Int hexCoords)&#10;    {&#10;        if (tilePool == null)&#10;        {&#10;            Debug.LogWarning(&quot;Tile pool is not assigned!&quot;);&#10;            return;&#10;        }&#10;        &#10;        // Vérifier que la colonne existe (qu'il y a une tile de base)&#10;        if (!tileColumns.ContainsKey(hexCoords))&#10;        {&#10;            Debug.LogWarning($&quot;No base tile found at hex ({hexCoords.x}, {hexCoords.y}). Cannot raise column.&quot;);&#10;            return;&#10;        }&#10;        &#10;        List&lt;GameObject&gt; column = tileColumns[hexCoords];&#10;        &#10;        // Obtenir la position de la tile de base pour avoir les bonnes coordonnées X et Z&#10;        GameObject baseTile = column[0];&#10;        if (baseTile == null)&#10;        {&#10;            Debug.LogWarning($&quot;Base tile at hex ({hexCoords.x}, {hexCoords.y}) is null. Cannot raise column.&quot;);&#10;            return;&#10;        }&#10;        &#10;        Vector3 basePosition = baseTile.transform.position;&#10;        &#10;        // Calculer la hauteur Y pour la nouvelle tile&#10;        // La tile de base (index 0) est à Y = 0, les tiles suivantes sont empilées au-dessus&#10;        float newTileY = (column.Count) * tileHeight;&#10;        &#10;        // Utiliser la position X et Z de la base, mais avec la nouvelle hauteur Y&#10;        Vector3 spawnPosition = new Vector3(basePosition.x, newTileY, basePosition.z);&#10;        &#10;        // Obtenir une tile du pool au lieu de l'instancier&#10;        GameObject newTile = tilePool.GetTile();&#10;        newTile.transform.position = spawnPosition;&#10;        newTile.transform.rotation = Quaternion.identity;&#10;        newTile.name = $&quot;Tile_({hexCoords.x}, {hexCoords.y})_H{column.Count}&quot;;&#10;        &#10;        // Ajouter la tile à la colonne&#10;        column.Add(newTile);&#10;        &#10;        // Debug.Log désactivé pour éviter le spam&#10;        // Debug.Log($&quot;Raised column at hex ({hexCoords.x}, {hexCoords.y}) to height {column.Count}. Spawned at Y={newTileY}&quot;);&#10;    }&#10;    &#10;    private void LowerColumn(Vector2Int hexCoords)&#10;    {&#10;        // Vérifier si la colonne existe&#10;        if (!tileColumns.ContainsKey(hexCoords))&#10;        {&#10;            Debug.LogWarning($&quot;No column found at hex ({hexCoords.x}, {hexCoords.y}). Cannot lower column.&quot;);&#10;            return;&#10;        }&#10;        &#10;        List&lt;GameObject&gt; column = tileColumns[hexCoords];&#10;        &#10;        // Vérifier qu'il y a au moins 2 tiles (base + une au-dessus)&#10;        // On ne peut pas détruire la tile de base (index 0)&#10;        if (column.Count &lt;= 1)&#10;        {&#10;            Debug.LogWarning($&quot;Column at hex ({hexCoords.x}, {hexCoords.y}) only has base tile. Cannot lower further.&quot;);&#10;            return;&#10;        }&#10;        &#10;        // Obtenir la dernière tile (au sommet de la colonne)&#10;        int lastIndex = column.Count - 1;&#10;        GameObject tileToRemove = column[lastIndex];&#10;        &#10;        // Retourner la tile au pool au lieu de la détruire&#10;        if (tileToRemove != null &amp;&amp; tilePool != null)&#10;        {&#10;            tilePool.ReleaseTile(tileToRemove);&#10;        }&#10;        &#10;        // Retirer la tile de la liste&#10;        column.RemoveAt(lastIndex);&#10;        &#10;        // Debug.Log désactivé pour éviter le spam&#10;        // Debug.Log($&quot;Lowered column at hex ({hexCoords.x}, {hexCoords.y}) to height {column.Count}. Returned tile to pool.&quot;);&#10;    }&#10;    &#10;    // Méthode publique pour obtenir la hauteur d'une colonne&#10;    public int GetColumnHeight(Vector2Int hexCoords)&#10;    {&#10;        if (tileColumns.ContainsKey(hexCoords))&#10;        {&#10;            return tileColumns[hexCoords].Count;&#10;        }&#10;        return 0;&#10;    }&#10;    &#10;    // Méthode publique pour enregistrer une tile de base créée par le TilemapManager&#10;    public void RegisterBaseTile(Vector2Int hexCoords, GameObject baseTile)&#10;    {&#10;        // Initialiser la colonne si elle n'existe pas encore&#10;        if (!tileColumns.ContainsKey(hexCoords))&#10;        {&#10;            tileColumns[hexCoords] = new List&lt;GameObject&gt;();&#10;        }&#10;        &#10;        // Ajouter la tile de base comme première tile de la colonne&#10;        tileColumns[hexCoords].Insert(0, baseTile);&#10;        &#10;        // Debug.Log désactivé pour éviter le spam&#10;        // Debug.Log($&quot;Registered base tile at hex ({hexCoords.x}, {hexCoords.y}) in TileHeightManager&quot;);&#10;    }&#10;    &#10;    // Méthode publique pour réinitialiser une colonne (détruire toutes les tiles au-dessus de la base)&#10;    public void ResetColumn(Vector2Int hexCoords)&#10;    {&#10;        if (tileColumns.ContainsKey(hexCoords))&#10;        {&#10;            List&lt;GameObject&gt; column = tileColumns[hexCoords];&#10;            &#10;            // Détruire toutes les tiles de la colonne sauf la première (tile de base)&#10;            for (int i = 1; i &lt; column.Count; i++)&#10;            {&#10;                if (column[i] != null &amp;&amp; tilePool != null)&#10;                {&#10;                    tilePool.ReleaseTile(column[i]);&#10;                }&#10;            }&#10;            &#10;            // Vider la liste&#10;            column.Clear();&#10;            tileColumns.Remove(hexCoords);&#10;        }&#10;    }&#10;    &#10;    // Méthode publique pour reset ET clear toute la colonne (y compris la base)&#10;    public void ResetAndClearColumn(Vector2Int hexCoords, TilePool pool)&#10;    {&#10;        if (tileColumns.ContainsKey(hexCoords))&#10;        {&#10;            List&lt;GameObject&gt; column = tileColumns[hexCoords];&#10;            &#10;            // Retourner TOUTES les tiles au pool (y compris la base, index 0)&#10;            // SAUF la base qui sera gérée par TilemapManagerCopy&#10;            for (int i = 1; i &lt; column.Count; i++)&#10;            {&#10;                if (column[i] != null &amp;&amp; pool != null)&#10;                {&#10;                    pool.ReleaseTile(column[i]);&#10;                }&#10;            }&#10;            &#10;            // Vider complètement la colonne&#10;            column.Clear();&#10;            tileColumns.Remove(hexCoords);&#10;        }&#10;    }&#10;    &#10;    // Méthode optimisée : reset seulement les tiles au-dessus, GARDER la base&#10;    public void ResetColumnKeepBase(Vector2Int hexCoords, TilePool pool)&#10;    {&#10;        if (!tileColumns.ContainsKey(hexCoords))&#10;        {&#10;            return; // Pas de colonne = rien à faire&#10;        }&#10;        &#10;        List&lt;GameObject&gt; column = tileColumns[hexCoords];&#10;        &#10;        // OPTIMISATION : Si la colonne n'a que la base (count == 1), ne rien faire !&#10;        if (column.Count &lt;= 1)&#10;        {&#10;            return; // Déjà resetée, évite le lag&#10;        }&#10;        &#10;        // Retourner SEULEMENT les tiles au-dessus de la base (index 1+)&#10;        for (int i = column.Count - 1; i &gt;= 1; i--)&#10;        {&#10;            if (column[i] != null &amp;&amp; pool != null)&#10;            {&#10;                pool.ReleaseTile(column[i]);&#10;            }&#10;        }&#10;        &#10;        // Garder la tile de base (index 0), retirer le reste&#10;        GameObject baseTile = column[0];&#10;        column.Clear();&#10;        column.Add(baseTile); // Remettre seulement la base&#10;        &#10;        // Debug.Log désactivé pour éviter le spam&#10;        // Debug.Log($&quot;Reset column at hex ({hexCoords.x}, {hexCoords.y}), kept base tile&quot;);&#10;    }&#10;    &#10;    // Convertir une position world en coordonnées axiales hexagonales (flat-top)&#10;    private Vector2Int WorldToHexAxial(Vector3 worldPosition)&#10;    {&#10;        float x = worldPosition.x;&#10;        float z = worldPosition.z;&#10;        &#10;        float sizeInternal = hexSize / 2f;&#10;        &#10;        float q = (2f / 3f * x) / sizeInternal;&#10;        float r = (-1f / 3f * x + Mathf.Sqrt(3f) / 3f * z) / sizeInternal;&#10;        &#10;        return HexRound(q, r);&#10;    }&#10;    &#10;    // Arrondir les coordonnées fractionnelles vers les coordonnées hexagonales entières&#10;    private Vector2Int HexRound(float q, float r)&#10;    {&#10;        float s = -q - r;&#10;        &#10;        int roundedQ = Mathf.RoundToInt(q);&#10;        int roundedR = Mathf.RoundToInt(r);&#10;        int roundedS = Mathf.RoundToInt(s);&#10;        &#10;        float qDiff = Mathf.Abs(roundedQ - q);&#10;        float rDiff = Mathf.Abs(roundedR - r);&#10;        float sDiff = Mathf.Abs(roundedS - s);&#10;        &#10;        if (qDiff &gt; rDiff &amp;&amp; qDiff &gt; sDiff)&#10;        {&#10;            roundedQ = -roundedR - roundedS;&#10;        }&#10;        else if (rDiff &gt; sDiff)&#10;        {&#10;            roundedR = -roundedQ - roundedS;&#10;        }&#10;        &#10;        return new Vector2Int(roundedQ, roundedR);&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;using System.Collections.Generic;&#10;&#10;public class TileHeightManager : MonoBehaviour&#10;{&#10;    [SerializeField] private TilePool tilePool; // Référence au pool de tiles&#10;    [SerializeField] private float tileHeight = .2f; // Hauteur d'une tile individuelle&#10;    [SerializeField] private float clickCooldown = 0.1f; // Temps minimum entre deux clics (en secondes)&#10;    [SerializeField] private BrushSizeManager brushManager; // Référence au BrushSizeManager&#10;    [SerializeField] private TileOcclusionCulling occlusionCulling; // Référence au système d'occlusion culling&#10;    [SerializeField] private float hexSize = 1f; // Largeur de l'hexagone (doit correspondre à TilemapManagerCopy)&#10;    &#10;    private Camera mainCamera;&#10;    // Dictionnaire qui stocke les colonnes de tiles par coordonnées hexagonales&#10;    // La clé est (q, r), la valeur est une liste de GameObjects empilés&#10;    private Dictionary&lt;Vector2Int, List&lt;GameObject&gt;&gt; tileColumns = new Dictionary&lt;Vector2Int, List&lt;GameObject&gt;&gt;();&#10;    private float lastClickTime; // Temps du dernier clic&#10;    &#10;    private void Start()&#10;    {&#10;        mainCamera = Camera.main;&#10;        if (mainCamera == null)&#10;        {&#10;            Debug.LogError(&quot;No main camera found in the scene!&quot;);&#10;        }&#10;        &#10;        if (tilePool == null)&#10;        {&#10;            Debug.LogError(&quot;TilePool is not assigned to TileHeightManager!&quot;);&#10;        }&#10;    }&#10;    &#10;    private void Update()&#10;    {&#10;        // Détecter le clic droit de la souris&#10;        if (Input.GetMouseButton(1))&#10;        {&#10;            // Vérifier si le cooldown est écoulé&#10;            if (Time.time &gt;= lastClickTime + clickCooldown)&#10;            {&#10;                // Shift + clic droit = baisser la colonne&#10;                if (Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift))&#10;                {&#10;                    DetectTileClickToLower();&#10;                }&#10;                else&#10;                {&#10;                    // Clic droit seul = monter la colonne&#10;                    DetectTileClick();&#10;                }&#10;                lastClickTime = Time.time;&#10;            }&#10;        }&#10;    }&#10;    &#10;    private void DetectTileClick()&#10;    {&#10;        // Obtenir la position de la souris à l'écran&#10;        Vector3 mouseScreenPosition = Input.mousePosition;&#10;        &#10;        // Créer un raycast depuis la caméra vers la position de la souris&#10;        Ray ray = mainCamera.ScreenPointToRay(mouseScreenPosition);&#10;        &#10;        // Calculer l'intersection avec le plan Y = 0 (comme BrushPreview)&#10;        Plane groundPlane = new Plane(Vector3.up, Vector3.zero);&#10;        float distance;&#10;        &#10;        if (groundPlane.Raycast(ray, out distance))&#10;        {&#10;            Vector3 worldPosition = ray.GetPoint(distance);&#10;            &#10;            // Visualiser le raycast en jaune&#10;            Debug.DrawRay(ray.origin, ray.direction * distance, Color.yellow, 2f);&#10;            &#10;            // Debug.Log désactivé pour éviter le spam&#10;            // Debug.Log($&quot;Click at world position: {worldPosition}, hex coords: ({hexCoords.x}, {hexCoords.y})&quot;);&#10;            &#10;            // Convertir la position world en coordonnées hexagonales (comme BrushPreview)&#10;            Vector2Int hexCoords = WorldToHexAxial(worldPosition);&#10;            &#10;            // Debug.Log désactivé pour éviter le spam&#10;            // Debug.Log($&quot;Raising {brushArea.Length} columns with brush size {brushManager.GetBrushSize()}&quot;);&#10;            &#10;            // Obtenir la zone du brush&#10;            Vector2Int[] brushArea;&#10;            if (brushManager != null)&#10;            {&#10;                brushArea = brushManager.GetBrushArea(hexCoords);&#10;                // Debug.Log désactivé pour éviter le spam&#10;                // Debug.Log($&quot;Raising {brushArea.Length} columns with brush size {brushManager.GetBrushSize()}&quot;);&#10;            }&#10;            else&#10;            {&#10;                // Si pas de brush manager, monter seulement une colonne&#10;                brushArea = new Vector2Int[] { hexCoords };&#10;            }&#10;            &#10;            // Monter toutes les colonnes dans la zone du brush&#10;            foreach (Vector2Int coord in brushArea)&#10;            {&#10;                RaiseColumn(coord);&#10;            }&#10;        }&#10;        else&#10;        {&#10;            Debug.DrawRay(ray.origin, ray.direction * 100f, Color.red, 2f);&#10;        }&#10;    }&#10;    &#10;    private void DetectTileClickToLower()&#10;    {&#10;        // Obtenir la position de la souris à l'écran&#10;        Vector3 mouseScreenPosition = Input.mousePosition;&#10;        &#10;        // Créer un raycast depuis la caméra vers la position de la souris&#10;        Ray ray = mainCamera.ScreenPointToRay(mouseScreenPosition);&#10;        &#10;        // Calculer l'intersection avec le plan Y = 0 (comme BrushPreview)&#10;        Plane groundPlane = new Plane(Vector3.up, Vector3.zero);&#10;        float distance;&#10;        &#10;        if (groundPlane.Raycast(ray, out distance))&#10;        {&#10;            Vector3 worldPosition = ray.GetPoint(distance);&#10;            &#10;            // Visualiser le raycast en magenta&#10;            Debug.DrawRay(ray.origin, ray.direction * distance, Color.magenta, 2f);&#10;            &#10;            // Convertir la position world en coordonnées hexagonales (comme BrushPreview)&#10;            Vector2Int hexCoords = WorldToHexAxial(worldPosition);&#10;            &#10;            // Debug.Log désactivé pour éviter le spam&#10;            // Debug.Log($&quot;Shift+Click at world position: {worldPosition}, hex coords: ({hexCoords.x}, {hexCoords.y})&quot;);&#10;            &#10;            // Obtenir la zone du brush&#10;            Vector2Int[] brushArea;&#10;            if (brushManager != null)&#10;            {&#10;                brushArea = brushManager.GetBrushArea(hexCoords);&#10;                // Debug.Log désactivé pour éviter le spam&#10;                // Debug.Log($&quot;Lowering {brushArea.Length} columns with brush size {brushManager.GetBrushSize()}&quot;);&#10;            }&#10;            else&#10;            {&#10;                // Si pas de brush manager, baisser seulement une colonne&#10;                brushArea = new Vector2Int[] { hexCoords };&#10;            }&#10;            &#10;            // Baisser toutes les colonnes dans la zone du brush&#10;            foreach (Vector2Int coord in brushArea)&#10;            {&#10;                LowerColumn(coord);&#10;            }&#10;        }&#10;        else&#10;        {&#10;            Debug.DrawRay(ray.origin, ray.direction * 100f, Color.red, 2f);&#10;        }&#10;    }&#10;    &#10;    private void RaiseColumn(Vector2Int hexCoords)&#10;    {&#10;        if (tilePool == null)&#10;        {&#10;            Debug.LogWarning(&quot;Tile pool is not assigned!&quot;);&#10;            return;&#10;        }&#10;        &#10;        // Vérifier que la colonne existe (qu'il y a une tile de base)&#10;        if (!tileColumns.ContainsKey(hexCoords))&#10;        {&#10;            Debug.LogWarning($&quot;No base tile found at hex ({hexCoords.x}, {hexCoords.y}). Cannot raise column.&quot;);&#10;            return;&#10;        }&#10;        &#10;        List&lt;GameObject&gt; column = tileColumns[hexCoords];&#10;        &#10;        // Obtenir la position de la tile de base pour avoir les bonnes coordonnées X et Z&#10;        GameObject baseTile = column[0];&#10;        if (baseTile == null)&#10;        {&#10;            Debug.LogWarning($&quot;Base tile at hex ({hexCoords.x}, {hexCoords.y}) is null. Cannot raise column.&quot;);&#10;            return;&#10;        }&#10;        &#10;        Vector3 basePosition = baseTile.transform.position;&#10;        &#10;        // Calculer la hauteur Y pour la nouvelle tile&#10;        // La tile de base (index 0) est à Y = 0, les tiles suivantes sont empilées au-dessus&#10;        float newTileY = (column.Count) * tileHeight;&#10;        &#10;        // Utiliser la position X et Z de la base, mais avec la nouvelle hauteur Y&#10;        Vector3 spawnPosition = new Vector3(basePosition.x, newTileY, basePosition.z);&#10;        &#10;        // Obtenir une tile du pool au lieu de l'instancier&#10;        GameObject newTile = tilePool.GetTile();&#10;        newTile.transform.position = spawnPosition;&#10;        newTile.transform.rotation = Quaternion.identity;&#10;        newTile.name = $&quot;Tile_({hexCoords.x}, {hexCoords.y})_H{column.Count}&quot;;&#10;        &#10;        // Ajouter la tile à la colonne&#10;        column.Add(newTile);&#10;        &#10;        // Enregistrer la tile dans le système d'occlusion culling&#10;        if (occlusionCulling != null)&#10;        {&#10;            occlusionCulling.RegisterTile(newTile);&#10;        }&#10;        &#10;        // Debug.Log désactivé pour éviter le spam&#10;        // Debug.Log($&quot;Raised column at hex ({hexCoords.x}, {hexCoords.y}) to height {column.Count}. Spawned at Y={newTileY}&quot;);&#10;    }&#10;    &#10;    private void LowerColumn(Vector2Int hexCoords)&#10;    {&#10;        // Vérifier si la colonne existe&#10;        if (!tileColumns.ContainsKey(hexCoords))&#10;        {&#10;            Debug.LogWarning($&quot;No column found at hex ({hexCoords.x}, {hexCoords.y}). Cannot lower column.&quot;);&#10;            return;&#10;        }&#10;        &#10;        List&lt;GameObject&gt; column = tileColumns[hexCoords];&#10;        &#10;        // Vérifier qu'il y a au moins 2 tiles (base + une au-dessus)&#10;        // On ne peut pas détruire la tile de base (index 0)&#10;        if (column.Count &lt;= 1)&#10;        {&#10;            Debug.LogWarning($&quot;Column at hex ({hexCoords.x}, {hexCoords.y}) only has base tile. Cannot lower further.&quot;);&#10;            return;&#10;        }&#10;        &#10;        // Obtenir la dernière tile (au sommet de la colonne)&#10;        int lastIndex = column.Count - 1;&#10;        GameObject tileToRemove = column[lastIndex];&#10;        &#10;        // Désenregistrer de l'occlusion culling&#10;        if (tileToRemove != null &amp;&amp; occlusionCulling != null)&#10;        {&#10;            occlusionCulling.UnregisterTile(tileToRemove);&#10;        }&#10;        &#10;        // Retourner la tile au pool au lieu de la détruire&#10;        if (tileToRemove != null &amp;&amp; tilePool != null)&#10;        {&#10;            tilePool.ReleaseTile(tileToRemove);&#10;        }&#10;        &#10;        // Retirer la tile de la liste&#10;        column.RemoveAt(lastIndex);&#10;        &#10;        // Debug.Log désactivé pour éviter le spam&#10;        // Debug.Log($&quot;Lowered column at hex ({hexCoords.x}, {hexCoords.y}) to height {column.Count}. Returned tile to pool.&quot;);&#10;    }&#10;    &#10;    // Méthode publique pour obtenir la hauteur d'une colonne&#10;    public int GetColumnHeight(Vector2Int hexCoords)&#10;    {&#10;        if (tileColumns.ContainsKey(hexCoords))&#10;        {&#10;            return tileColumns[hexCoords].Count;&#10;        }&#10;        return 0;&#10;    }&#10;    &#10;    // Méthode publique pour enregistrer une tile de base créée par le TilemapManager&#10;    public void RegisterBaseTile(Vector2Int hexCoords, GameObject baseTile)&#10;    {&#10;        // Initialiser la colonne si elle n'existe pas encore&#10;        if (!tileColumns.ContainsKey(hexCoords))&#10;        {&#10;            tileColumns[hexCoords] = new List&lt;GameObject&gt;();&#10;        }&#10;        &#10;        // Ajouter la tile de base comme première tile de la colonne&#10;        tileColumns[hexCoords].Insert(0, baseTile);&#10;        &#10;        // Debug.Log désactivé pour éviter le spam&#10;        // Debug.Log($&quot;Registered base tile at hex ({hexCoords.x}, {hexCoords.y}) in TileHeightManager&quot;);&#10;    }&#10;    &#10;    // Méthode publique pour réinitialiser une colonne (détruire toutes les tiles au-dessus de la base)&#10;    public void ResetColumn(Vector2Int hexCoords)&#10;    {&#10;        if (tileColumns.ContainsKey(hexCoords))&#10;        {&#10;            List&lt;GameObject&gt; column = tileColumns[hexCoords];&#10;            &#10;            // Détruire toutes les tiles de la colonne sauf la première (tile de base)&#10;            for (int i = 1; i &lt; column.Count; i++)&#10;            {&#10;                if (column[i] != null &amp;&amp; tilePool != null)&#10;                {&#10;                    tilePool.ReleaseTile(column[i]);&#10;                }&#10;            }&#10;            &#10;            // Vider la liste&#10;            column.Clear();&#10;            tileColumns.Remove(hexCoords);&#10;        }&#10;    }&#10;    &#10;    // Méthode publique pour reset ET clear toute la colonne (y compris la base)&#10;    public void ResetAndClearColumn(Vector2Int hexCoords, TilePool pool)&#10;    {&#10;        if (tileColumns.ContainsKey(hexCoords))&#10;        {&#10;            List&lt;GameObject&gt; column = tileColumns[hexCoords];&#10;            &#10;            // Retourner TOUTES les tiles au pool (y compris la base, index 0)&#10;            // SAUF la base qui sera gérée par TilemapManagerCopy&#10;            for (int i = 1; i &lt; column.Count; i++)&#10;            {&#10;                if (column[i] != null &amp;&amp; pool != null)&#10;                {&#10;                    pool.ReleaseTile(column[i]);&#10;                }&#10;            }&#10;            &#10;            // Vider complètement la colonne&#10;            column.Clear();&#10;            tileColumns.Remove(hexCoords);&#10;        }&#10;    }&#10;    &#10;    // Méthode optimisée : reset seulement les tiles au-dessus, GARDER la base&#10;    public void ResetColumnKeepBase(Vector2Int hexCoords, TilePool pool)&#10;    {&#10;        if (!tileColumns.ContainsKey(hexCoords))&#10;        {&#10;            return; // Pas de colonne = rien à faire&#10;        }&#10;        &#10;        List&lt;GameObject&gt; column = tileColumns[hexCoords];&#10;        &#10;        // OPTIMISATION : Si la colonne n'a que la base (count == 1), ne rien faire !&#10;        if (column.Count &lt;= 1)&#10;        {&#10;            return; // Déjà resetée, évite le lag&#10;        }&#10;        &#10;        // Retourner SEULEMENT les tiles au-dessus de la base (index 1+)&#10;        for (int i = column.Count - 1; i &gt;= 1; i--)&#10;        {&#10;            if (column[i] != null)&#10;            {&#10;                // Désenregistrer de l'occlusion culling&#10;                if (occlusionCulling != null)&#10;                {&#10;                    occlusionCulling.UnregisterTile(column[i]);&#10;                }&#10;                &#10;                // Retourner au pool&#10;                if (pool != null)&#10;                {&#10;                    pool.ReleaseTile(column[i]);&#10;                }&#10;            }&#10;        }&#10;        &#10;        // Garder la tile de base (index 0), retirer le reste&#10;        GameObject baseTile = column[0];&#10;        column.Clear();&#10;        column.Add(baseTile); // Remettre seulement la base&#10;        &#10;        // Debug.Log désactivé pour éviter le spam&#10;        // Debug.Log($&quot;Reset column at hex ({hexCoords.x}, {hexCoords.y}), kept base tile&quot;);&#10;    }&#10;    &#10;    // Convertir une position world en coordonnées axiales hexagonales (flat-top)&#10;    private Vector2Int WorldToHexAxial(Vector3 worldPosition)&#10;    {&#10;        float x = worldPosition.x;&#10;        float z = worldPosition.z;&#10;        &#10;        float sizeInternal = hexSize / 2f;&#10;        &#10;        float q = (2f / 3f * x) / sizeInternal;&#10;        float r = (-1f / 3f * x + Mathf.Sqrt(3f) / 3f * z) / sizeInternal;&#10;        &#10;        return HexRound(q, r);&#10;    }&#10;    &#10;    // Arrondir les coordonnées fractionnelles vers les coordonnées hexagonales entières&#10;    private Vector2Int HexRound(float q, float r)&#10;    {&#10;        float s = -q - r;&#10;        &#10;        int roundedQ = Mathf.RoundToInt(q);&#10;        int roundedR = Mathf.RoundToInt(r);&#10;        int roundedS = Mathf.RoundToInt(s);&#10;        &#10;        float qDiff = Mathf.Abs(roundedQ - q);&#10;        float rDiff = Mathf.Abs(roundedR - r);&#10;        float sDiff = Mathf.Abs(roundedS - s);&#10;        &#10;        if (qDiff &gt; rDiff &amp;&amp; qDiff &gt; sDiff)&#10;        {&#10;            roundedQ = -roundedR - roundedS;&#10;        }&#10;        else if (rDiff &gt; sDiff)&#10;        {&#10;            roundedR = -roundedQ - roundedS;&#10;        }&#10;        &#10;        return new Vector2Int(roundedQ, roundedR);&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Managers/TileOcclusionCulling.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Managers/TileOcclusionCulling.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using System.Collections.Generic;&#10;&#10;public class TileOcclusionCulling : MonoBehaviour&#10;{&#10;    [Header(&quot;Settings&quot;)]&#10;    [SerializeField] private Camera targetCamera;&#10;    [SerializeField] private float updateInterval = 0.2f; // Mise à jour 5 fois par seconde&#10;    [SerializeField] private float cullingDistance = 50f; // Distance max de rendu&#10;    [SerializeField] private bool enableDistanceCulling = true;&#10;    [SerializeField] private bool enableFrustumCulling = true;&#10;    &#10;    [Header(&quot;Debug&quot;)]&#10;    [SerializeField] private bool showDebugInfo = false;&#10;    &#10;    private float lastUpdateTime;&#10;    private Dictionary&lt;GameObject, Renderer[]&gt; tileRenderers = new Dictionary&lt;GameObject, Renderer[]&gt;();&#10;    private int visibleCount;&#10;    private int totalCount;&#10;    &#10;    private void Start()&#10;    {&#10;        if (targetCamera == null)&#10;        {&#10;            targetCamera = Camera.main;&#10;        }&#10;        &#10;        if (targetCamera == null)&#10;        {&#10;            Debug.LogError(&quot;TileOcclusionCulling: No camera found!&quot;);&#10;            enabled = false;&#10;        }&#10;    }&#10;    &#10;    private void Update()&#10;    {&#10;        // Mise à jour à intervalle régulier pour éviter de surcharger&#10;        if (Time.time &gt;= lastUpdateTime + updateInterval)&#10;        {&#10;            UpdateVisibility();&#10;            lastUpdateTime = Time.time;&#10;        }&#10;    }&#10;    &#10;    // Enregistrer une tile pour le culling&#10;    public void RegisterTile(GameObject tile)&#10;    {&#10;        if (tile == null || tileRenderers.ContainsKey(tile))&#10;            return;&#10;        &#10;        // Récupérer tous les renderers de la tile&#10;        Renderer[] renderers = tile.GetComponentsInChildren&lt;Renderer&gt;();&#10;        if (renderers.Length &gt; 0)&#10;        {&#10;            tileRenderers[tile] = renderers;&#10;        }&#10;    }&#10;    &#10;    // Désenregistrer une tile&#10;    public void UnregisterTile(GameObject tile)&#10;    {&#10;        if (tile != null &amp;&amp; tileRenderers.ContainsKey(tile))&#10;        {&#10;            tileRenderers.Remove(tile);&#10;        }&#10;    }&#10;    &#10;    // Mettre à jour la visibilité de toutes les tiles&#10;    private void UpdateVisibility()&#10;    {&#10;        if (targetCamera == null)&#10;            return;&#10;        &#10;        visibleCount = 0;&#10;        totalCount = tileRenderers.Count;&#10;        &#10;        Vector3 cameraPos = targetCamera.transform.position;&#10;        Plane[] frustumPlanes = GeometryUtility.CalculateFrustumPlanes(targetCamera);&#10;        &#10;        foreach (var kvp in tileRenderers)&#10;        {&#10;            GameObject tile = kvp.Key;&#10;            Renderer[] renderers = kvp.Value;&#10;            &#10;            // Vérifier si la tile existe toujours&#10;            if (tile == null || renderers == null || renderers.Length == 0)&#10;                continue;&#10;            &#10;            bool isVisible = true;&#10;            &#10;            // Test 1: Distance culling&#10;            if (enableDistanceCulling)&#10;            {&#10;                float distance = Vector3.Distance(cameraPos, tile.transform.position);&#10;                if (distance &gt; cullingDistance)&#10;                {&#10;                    isVisible = false;&#10;                }&#10;            }&#10;            &#10;            // Test 2: Frustum culling (si toujours visible après distance check)&#10;            if (isVisible &amp;&amp; enableFrustumCulling)&#10;            {&#10;                // Vérifier si au moins un renderer est dans le frustum&#10;                bool inFrustum = false;&#10;                foreach (Renderer renderer in renderers)&#10;                {&#10;                    if (renderer != null &amp;&amp; GeometryUtility.TestPlanesAABB(frustumPlanes, renderer.bounds))&#10;                    {&#10;                        inFrustum = true;&#10;                        break;&#10;                    }&#10;                }&#10;                isVisible = inFrustum;&#10;            }&#10;            &#10;            // Activer/désactiver les renderers&#10;            foreach (Renderer renderer in renderers)&#10;            {&#10;                if (renderer != null &amp;&amp; renderer.enabled != isVisible)&#10;                {&#10;                    renderer.enabled = isVisible;&#10;                }&#10;            }&#10;            &#10;            if (isVisible)&#10;            {&#10;                visibleCount++;&#10;            }&#10;        }&#10;    }&#10;    &#10;    // Forcer une mise à jour immédiate&#10;    public void ForceUpdate()&#10;    {&#10;        UpdateVisibility();&#10;    }&#10;    &#10;    // Nettoyer les tiles nulles du dictionnaire&#10;    public void CleanupNullTiles()&#10;    {&#10;        List&lt;GameObject&gt; toRemove = new List&lt;GameObject&gt;();&#10;        &#10;        foreach (var kvp in tileRenderers)&#10;        {&#10;            if (kvp.Key == null)&#10;            {&#10;                toRemove.Add(kvp.Key);&#10;            }&#10;        }&#10;        &#10;        foreach (GameObject tile in toRemove)&#10;        {&#10;            tileRenderers.Remove(tile);&#10;        }&#10;    }&#10;    &#10;    // Afficher les stats dans l'éditeur&#10;    private void OnGUI()&#10;    {&#10;        if (showDebugInfo)&#10;        {&#10;            GUIStyle style = new GUIStyle();&#10;            style.normal.textColor = Color.white;&#10;            style.fontSize = 16;&#10;            &#10;            GUI.Label(new Rect(10, 10, 300, 30), $&quot;Tiles Visible: {visibleCount} / {totalCount}&quot;, style);&#10;            GUI.Label(new Rect(10, 40, 300, 30), $&quot;Culled: {totalCount - visibleCount} ({(totalCount &gt; 0 ? (100f * (totalCount - visibleCount) / totalCount) : 0):F1}%)&quot;, style);&#10;        }&#10;    }&#10;    &#10;    // Getter pour les stats&#10;    public int GetVisibleCount() =&gt; visibleCount;&#10;    public int GetTotalCount() =&gt; totalCount;&#10;    public int GetCulledCount() =&gt; totalCount - visibleCount;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/Managers/TilemapManagerCopy.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/Managers/TilemapManagerCopy.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using System.Collections.Generic;&#10;&#10;public class TilemapManagerCopy : MonoBehaviour&#10;{&#10;    [SerializeField] private TilePool tilePool; // Référence au pool de tiles&#10;    [SerializeField] private float hexSize = 1f; // Largeur de l'hexagone (distance entre côtés opposés pour flat-top)&#10;    [SerializeField] private TileHeightManager heightManager; // Référence au TileHeightManager&#10;    [SerializeField] private BrushSizeManager brushManager; // Référence au BrushSizeManager&#10;    [SerializeField] private float clickCooldown = 0.1f; // Temps minimum entre deux placements (en secondes)&#10;    [SerializeField] private bool allowReplacement = true; // Permettre le remplacement des tiles existantes&#10;    &#10;    private Camera mainCamera;&#10;    private Dictionary&lt;Vector2Int, GameObject&gt; tiles = new Dictionary&lt;Vector2Int, GameObject&gt;();&#10;    private float lastClickTime;&#10;    &#10;    private void Start()&#10;    {&#10;        mainCamera = Camera.main;&#10;        if (mainCamera == null)&#10;        {&#10;            Debug.LogError(&quot;No main camera found in the scene!&quot;);&#10;        }&#10;        &#10;        if (tilePool == null)&#10;        {&#10;            Debug.LogError(&quot;TilePool is not assigned to TilemapManagerCopy!&quot;);&#10;        }&#10;    }&#10;    &#10;    private void Update()&#10;    {&#10;        // Détecter le clic gauche de la souris&#10;        if (Input.GetMouseButton(0))&#10;        {&#10;            // Vérifier si le cooldown est écoulé&#10;            if (Time.time &gt;= lastClickTime + clickCooldown)&#10;            {&#10;                DetectMouseClick();&#10;                lastClickTime = Time.time;&#10;            }&#10;        }&#10;    }&#10;    &#10;    private void DetectMouseClick()&#10;    {&#10;        // Obtenir la position de la souris à l'écran&#10;        Vector3 mouseScreenPosition = Input.mousePosition;&#10;        &#10;        // Créer un raycast depuis la caméra vers la position de la souris&#10;        Ray ray = mainCamera.ScreenPointToRay(mouseScreenPosition);&#10;        RaycastHit hit;&#10;        &#10;        Vector3 worldPosition;&#10;        &#10;        // Effectuer le raycast&#10;        if (Physics.Raycast(ray, out hit))&#10;        {&#10;            // Position exacte du clic en coordonnées world si un objet est touché&#10;            worldPosition = hit.point;&#10;            &#10;            // Visualiser le raycast en vert jusqu'au point d'impact&#10;            Debug.DrawRay(ray.origin, ray.direction * hit.distance, Color.green, 2f);&#10;            &#10;            // Dessiner une croix à la position du hit&#10;            DrawCross(worldPosition, Color.green, 0.5f, 2f);&#10;        }&#10;        else&#10;        {&#10;            // Si aucun objet n'est touché, calculer l'intersection avec le plan Y = 0&#10;            Plane groundPlane = new Plane(Vector3.up, Vector3.zero);&#10;            float distance;&#10;            &#10;            if (groundPlane.Raycast(ray, out distance))&#10;            {&#10;                worldPosition = ray.GetPoint(distance);&#10;                &#10;                // Visualiser le raycast en cyan jusqu'au plan&#10;                Debug.DrawRay(ray.origin, ray.direction * distance, Color.cyan, 2f);&#10;                &#10;                // Dessiner une croix à la position calculée&#10;                DrawCross(worldPosition, Color.cyan, 0.5f, 2f);&#10;            }&#10;            else&#10;            {&#10;                // Visualiser le raycast en rouge si aucune intersection&#10;                Debug.DrawRay(ray.origin, ray.direction * 100f, Color.red, 2f);&#10;                Debug.LogWarning(&quot;Could not calculate world position&quot;);&#10;                return;&#10;            }&#10;        }&#10;        &#10;        // Convertir la position world en coordonnées axiales hexagonales&#10;        Vector2Int hexCoords = WorldToHexAxial(worldPosition);&#10;        &#10;        // Obtenir la zone du brush&#10;        Vector2Int[] brushArea;&#10;        if (brushManager != null)&#10;        {&#10;            brushArea = brushManager.GetBrushArea(hexCoords);&#10;        }&#10;        else&#10;        {&#10;            // Si pas de brush manager, spawner seulement une tile&#10;            brushArea = new Vector2Int[] { hexCoords };&#10;        }&#10;        &#10;        // Spawner les tiles dans la zone du brush&#10;        foreach (Vector2Int coord in brushArea)&#10;        {&#10;            SpawnTileAt(coord);&#10;        }&#10;    }&#10;    &#10;    private void SpawnTileAt(Vector2Int hexCoords)&#10;    {&#10;        if (tilePool == null)&#10;        {&#10;            Debug.LogWarning(&quot;Tile pool is not assigned!&quot;);&#10;            return;&#10;        }&#10;        &#10;        // Vérifier si une tile existe déjà à cette position&#10;        if (tiles.ContainsKey(hexCoords))&#10;        {&#10;            if (!allowReplacement)&#10;            {&#10;                // Ne pas remplacer si le remplacement est désactivé&#10;                return;&#10;            }&#10;            &#10;            // La tile existe déjà : JUSTE reset la colonne au-dessus (optimisation)&#10;            // Debug.Log désactivé pour éviter le spam et le lag&#10;            // Debug.Log($&quot;Tile already exists at ({hexCoords.x}, {hexCoords.y}). Only resetting column above.&quot;);&#10;            &#10;            // Retourner SEULEMENT les tiles de hauteur au pool, garder la base&#10;            if (heightManager != null)&#10;            {&#10;                heightManager.ResetColumnKeepBase(hexCoords, tilePool);&#10;            }&#10;            &#10;            // Ne rien faire d'autre - la tile de base reste en place&#10;            return;&#10;        }&#10;        &#10;        // Convertir les coordonnées hexagonales en position world&#10;        Vector3 spawnPosition = HexAxialToWorld(hexCoords.x, hexCoords.y);&#10;        &#10;        // Obtenir une tile du pool (nouvelle tile uniquement)&#10;        GameObject tile = tilePool.GetTile();&#10;        tile.transform.position = spawnPosition;&#10;        tile.transform.rotation = Quaternion.identity;&#10;        tile.name = $&quot;Tile_({hexCoords.x}, {hexCoords.y})&quot;;&#10;        &#10;        // Ajouter la tile au dictionnaire&#10;        tiles.Add(hexCoords, tile);&#10;        &#10;        // Notifier le height manager de la nouvelle tile de base&#10;        if (heightManager != null)&#10;        {&#10;            heightManager.RegisterBaseTile(hexCoords, tile);&#10;        }&#10;        &#10;        // Debug.Log désactivé pour éviter le spam et le lag&#10;        // Debug.Log($&quot;Spawned NEW tile at hex ({hexCoords.x}, {hexCoords.y}) from pool. Active tiles: {tilePool.CountActive}&quot;);&#10;    }&#10;    &#10;    // Convertir une position world en coordonnées axiales hexagonales (flat-top)&#10;    private Vector2Int WorldToHexAxial(Vector3 worldPosition)&#10;    {&#10;        // Pour flat-top hexagons avec largeur (width = distance entre côtés opposés):&#10;        // La largeur correspond à 2 * taille_interne&#10;        // Donc taille_interne = largeur / 2&#10;        &#10;        float x = worldPosition.x;&#10;        float z = worldPosition.z;&#10;        &#10;        float sizeInternal = hexSize / 2f;&#10;        &#10;        float q = (2f / 3f * x) / sizeInternal;&#10;        float r = (-1f / 3f * x + Mathf.Sqrt(3f) / 3f * z) / sizeInternal;&#10;        &#10;        // Arrondir aux coordonnées hexagonales entières&#10;        return HexRound(q, r);&#10;    }&#10;    &#10;    // Arrondir les coordonnées fractionnelles vers les coordonnées hexagonales entières&#10;    private Vector2Int HexRound(float q, float r)&#10;    {&#10;        float s = -q - r; // coordonnée cubique s&#10;        &#10;        int roundedQ = Mathf.RoundToInt(q);&#10;        int roundedR = Mathf.RoundToInt(r);&#10;        int roundedS = Mathf.RoundToInt(s);&#10;        &#10;        float qDiff = Mathf.Abs(roundedQ - q);&#10;        float rDiff = Mathf.Abs(roundedR - r);&#10;        float sDiff = Mathf.Abs(roundedS - s);&#10;        &#10;        // Réajuster la coordonnée avec la plus grande différence&#10;        if (qDiff &gt; rDiff &amp;&amp; qDiff &gt; sDiff)&#10;        {&#10;            roundedQ = -roundedR - roundedS;&#10;        }&#10;        else if (rDiff &gt; sDiff)&#10;        {&#10;            roundedR = -roundedQ - roundedS;&#10;        }&#10;        &#10;        return new Vector2Int(roundedQ, roundedR);&#10;    }&#10;    &#10;    // Convertir des coordonnées axiales hexagonales en position world (si nécessaire)&#10;    private Vector3 HexAxialToWorld(int q, int r)&#10;    {&#10;        // Pour flat-top hexagons avec largeur (width):&#10;        // La largeur correspond à 2 * taille_interne&#10;        // Donc taille_interne = largeur / 2&#10;        &#10;        float sizeInternal = hexSize / 2f;&#10;        &#10;        float x = sizeInternal * (3f / 2f * q);&#10;        float z = sizeInternal * (Mathf.Sqrt(3f) / 2f * q + Mathf.Sqrt(3f) * r);&#10;        &#10;        return new Vector3(x, 0f, z);&#10;    }&#10;    &#10;    // Dessiner une croix pour visualiser la position&#10;    private void DrawCross(Vector3 position, Color color, float size, float duration)&#10;    {&#10;        // Croix sur le plan XY&#10;        Debug.DrawLine(position + Vector3.left * size, position + Vector3.right * size, color, duration);&#10;        Debug.DrawLine(position + Vector3.up * size, position + Vector3.down * size, color, duration);&#10;        &#10;        // Ligne verticale sur Z&#10;        Debug.DrawLine(position + Vector3.forward * size, position + Vector3.back * size, color, duration);&#10;    }&#10;}" />
              <option name="updatedContent" value="using UnityEngine;&#10;using System.Collections.Generic;&#10;&#10;public class TilemapManagerCopy : MonoBehaviour&#10;{&#10;    [SerializeField] private TilePool tilePool; // Référence au pool de tiles&#10;    [SerializeField] private float hexSize = 1f; // Largeur de l'hexagone (distance entre côtés opposés pour flat-top)&#10;    [SerializeField] private TileHeightManager heightManager; // Référence au TileHeightManager&#10;    [SerializeField] private BrushSizeManager brushManager; // Référence au BrushSizeManager&#10;    [SerializeField] private TileOcclusionCulling occlusionCulling; // Référence au système d'occlusion culling&#10;    [SerializeField] private float clickCooldown = 0.1f; // Temps minimum entre deux placements (en secondes)&#10;    [SerializeField] private bool allowReplacement = true; // Permettre le remplacement des tiles existantes&#10;    &#10;    private Camera mainCamera;&#10;    private Dictionary&lt;Vector2Int, GameObject&gt; tiles = new Dictionary&lt;Vector2Int, GameObject&gt;();&#10;    private float lastClickTime;&#10;    &#10;    private void Start()&#10;    {&#10;        mainCamera = Camera.main;&#10;        if (mainCamera == null)&#10;        {&#10;            Debug.LogError(&quot;No main camera found in the scene!&quot;);&#10;        }&#10;        &#10;        if (tilePool == null)&#10;        {&#10;            Debug.LogError(&quot;TilePool is not assigned to TilemapManagerCopy!&quot;);&#10;        }&#10;    }&#10;    &#10;    private void Update()&#10;    {&#10;        // Détecter le clic gauche de la souris&#10;        if (Input.GetMouseButton(0))&#10;        {&#10;            // Vérifier si le cooldown est écoulé&#10;            if (Time.time &gt;= lastClickTime + clickCooldown)&#10;            {&#10;                DetectMouseClick();&#10;                lastClickTime = Time.time;&#10;            }&#10;        }&#10;    }&#10;    &#10;    private void DetectMouseClick()&#10;    {&#10;        // Obtenir la position de la souris à l'écran&#10;        Vector3 mouseScreenPosition = Input.mousePosition;&#10;        &#10;        // Créer un raycast depuis la caméra vers la position de la souris&#10;        Ray ray = mainCamera.ScreenPointToRay(mouseScreenPosition);&#10;        RaycastHit hit;&#10;        &#10;        Vector3 worldPosition;&#10;        &#10;        // Effectuer le raycast&#10;        if (Physics.Raycast(ray, out hit))&#10;        {&#10;            // Position exacte du clic en coordonnées world si un objet est touché&#10;            worldPosition = hit.point;&#10;            &#10;            // Visualiser le raycast en vert jusqu'au point d'impact&#10;            Debug.DrawRay(ray.origin, ray.direction * hit.distance, Color.green, 2f);&#10;            &#10;            // Dessiner une croix à la position du hit&#10;            DrawCross(worldPosition, Color.green, 0.5f, 2f);&#10;        }&#10;        else&#10;        {&#10;            // Si aucun objet n'est touché, calculer l'intersection avec le plan Y = 0&#10;            Plane groundPlane = new Plane(Vector3.up, Vector3.zero);&#10;            float distance;&#10;            &#10;            if (groundPlane.Raycast(ray, out distance))&#10;            {&#10;                worldPosition = ray.GetPoint(distance);&#10;                &#10;                // Visualiser le raycast en cyan jusqu'au plan&#10;                Debug.DrawRay(ray.origin, ray.direction * distance, Color.cyan, 2f);&#10;                &#10;                // Dessiner une croix à la position calculée&#10;                DrawCross(worldPosition, Color.cyan, 0.5f, 2f);&#10;            }&#10;            else&#10;            {&#10;                // Visualiser le raycast en rouge si aucune intersection&#10;                Debug.DrawRay(ray.origin, ray.direction * 100f, Color.red, 2f);&#10;                Debug.LogWarning(&quot;Could not calculate world position&quot;);&#10;                return;&#10;            }&#10;        }&#10;        &#10;        // Convertir la position world en coordonnées axiales hexagonales&#10;        Vector2Int hexCoords = WorldToHexAxial(worldPosition);&#10;        &#10;        // Obtenir la zone du brush&#10;        Vector2Int[] brushArea;&#10;        if (brushManager != null)&#10;        {&#10;            brushArea = brushManager.GetBrushArea(hexCoords);&#10;        }&#10;        else&#10;        {&#10;            // Si pas de brush manager, spawner seulement une tile&#10;            brushArea = new Vector2Int[] { hexCoords };&#10;        }&#10;        &#10;        // Spawner les tiles dans la zone du brush&#10;        foreach (Vector2Int coord in brushArea)&#10;        {&#10;            SpawnTileAt(coord);&#10;        }&#10;    }&#10;    &#10;    private void SpawnTileAt(Vector2Int hexCoords)&#10;    {&#10;        if (tilePool == null)&#10;        {&#10;            Debug.LogWarning(&quot;Tile pool is not assigned!&quot;);&#10;            return;&#10;        }&#10;        &#10;        // Vérifier si une tile existe déjà à cette position&#10;        if (tiles.ContainsKey(hexCoords))&#10;        {&#10;            if (!allowReplacement)&#10;            {&#10;                // Ne pas remplacer si le remplacement est désactivé&#10;                return;&#10;            }&#10;            &#10;            // La tile existe déjà : JUSTE reset la colonne au-dessus (optimisation)&#10;            // Debug.Log désactivé pour éviter le spam et le lag&#10;            // Debug.Log($&quot;Tile already exists at ({hexCoords.x}, {hexCoords.y}). Only resetting column above.&quot;);&#10;            &#10;            // Retourner SEULEMENT les tiles de hauteur au pool, garder la base&#10;            if (heightManager != null)&#10;            {&#10;                heightManager.ResetColumnKeepBase(hexCoords, tilePool);&#10;            }&#10;            &#10;            // Ne rien faire d'autre - la tile de base reste en place&#10;            return;&#10;        }&#10;        Vector3 spawnPosition = HexAxialToWorld(hexCoords.x, hexCoords.y);&#10;        &#10;        // Obtenir une tile du pool (nouvelle tile uniquement)&#10;        GameObject tile = tilePool.GetTile();&#10;        tile.transform.position = spawnPosition;&#10;        tile.transform.rotation = Quaternion.identity;&#10;        tile.name = $&quot;Tile_({hexCoords.x}, {hexCoords.y})&quot;;&#10;        &#10;        // Ajouter la tile au dictionnaire&#10;        tiles.Add(hexCoords, tile);&#10;        &#10;        // Notifier le height manager de la nouvelle tile de base&#10;        if (heightManager != null)&#10;        {&#10;            heightManager.RegisterBaseTile(hexCoords, tile);&#10;        }&#10;        &#10;        // Enregistrer la tile dans le système d'occlusion culling&#10;        if (occlusionCulling != null)&#10;        {&#10;            occlusionCulling.RegisterTile(tile);&#10;        }&#10;    }&#10;    &#10;    // Convertir une position world en coordonnées axiales hexagonales (flat-top)&#10;    private Vector2Int WorldToHexAxial(Vector3 worldPosition)&#10;    {&#10;        // Pour flat-top hexagons avec largeur (width = distance entre côtés opposés):&#10;        // La largeur correspond à 2 * taille_interne&#10;        // Donc taille_interne = largeur / 2&#10;        &#10;        float x = worldPosition.x;&#10;        float z = worldPosition.z;&#10;        &#10;        float sizeInternal = hexSize / 2f;&#10;        &#10;        float q = (2f / 3f * x) / sizeInternal;&#10;        float r = (-1f / 3f * x + Mathf.Sqrt(3f) / 3f * z) / sizeInternal;&#10;        &#10;        // Arrondir aux coordonnées hexagonales entières&#10;        return HexRound(q, r);&#10;    }&#10;    &#10;    // Arrondir les coordonnées fractionnelles vers les coordonnées hexagonales entières&#10;    private Vector2Int HexRound(float q, float r)&#10;    {&#10;        float s = -q - r; // coordonnée cubique s&#10;        &#10;        int roundedQ = Mathf.RoundToInt(q);&#10;        int roundedR = Mathf.RoundToInt(r);&#10;        int roundedS = Mathf.RoundToInt(s);&#10;        &#10;        float qDiff = Mathf.Abs(roundedQ - q);&#10;        float rDiff = Mathf.Abs(roundedR - r);&#10;        float sDiff = Mathf.Abs(roundedS - s);&#10;        &#10;        // Réajuster la coordonnée avec la plus grande différence&#10;        if (qDiff &gt; rDiff &amp;&amp; qDiff &gt; sDiff)&#10;        {&#10;            roundedQ = -roundedR - roundedS;&#10;        }&#10;        else if (rDiff &gt; sDiff)&#10;        {&#10;            roundedR = -roundedQ - roundedS;&#10;        }&#10;        &#10;        return new Vector2Int(roundedQ, roundedR);&#10;    }&#10;    &#10;    // Convertir des coordonnées axiales hexagonales en position world (si nécessaire)&#10;    private Vector3 HexAxialToWorld(int q, int r)&#10;    {&#10;        // Pour flat-top hexagons avec largeur (width):&#10;        // La largeur correspond à 2 * taille_interne&#10;        // Donc taille_interne = largeur / 2&#10;        &#10;        float sizeInternal = hexSize / 2f;&#10;        &#10;        float x = sizeInternal * (3f / 2f * q);&#10;        float z = sizeInternal * (Mathf.Sqrt(3f) / 2f * q + Mathf.Sqrt(3f) * r);&#10;        &#10;        return new Vector3(x, 0f, z);&#10;    }&#10;    &#10;    // Dessiner une croix pour visualiser la position&#10;    private void DrawCross(Vector3 position, Color color, float size, float duration)&#10;    {&#10;        // Croix sur le plan XY&#10;        Debug.DrawLine(position + Vector3.left * size, position + Vector3.right * size, color, duration);&#10;        Debug.DrawLine(position + Vector3.up * size, position + Vector3.down * size, color, duration);&#10;        &#10;        // Ligne verticale sur Z&#10;        Debug.DrawLine(position + Vector3.forward * size, position + Vector3.back * size, color, duration);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>